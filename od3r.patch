diff -Naur inet_orig/src/inet/applications/udpapp/UdpBasicOd3rApp.cc inet_od3r/src/inet/applications/udpapp/UdpBasicOd3rApp.cc
--- inet_orig/src/inet/applications/udpapp/UdpBasicOd3rApp.cc	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/applications/udpapp/UdpBasicOd3rApp.cc	2023-12-20 17:28:39.425267654 +0100
@@ -0,0 +1,556 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#include "UdpBasicOd3rApp.h"
+
+#include "inet/applications/base/ApplicationPacket_m.h"
+
+#include "inet/common/TimeTag_m.h"
+#include "inet/common/lifecycle/ModuleOperations.h"
+#include "inet/common/packet/Packet.h"
+#include "inet/networklayer/common/FragmentationTag_m.h"
+#include "inet/networklayer/common/L3AddressResolver.h"
+
+namespace inet {
+
+EXECUTE_ON_STARTUP(
+        cEnum * e = cEnum::find("inet::ChooseDestAddrMode");
+        if (!e)
+            omnetpp::internal::enums.getInstance()->add(e = new cEnum("inet::ChooseDestAddrMode"));
+        e->insert(UdpBasicOd3rApp::ONCE, "once");
+        e->insert(UdpBasicOd3rApp::PER_BURST, "perBurst");
+        e->insert(UdpBasicOd3rApp::PER_SEND, "perSend");
+        );
+
+Define_Module(UdpBasicOd3rApp);
+
+int UdpBasicOd3rApp::counter;
+
+UdpBasicOd3rApp::~UdpBasicOd3rApp()
+{
+    cancelAndDelete(selfMsg);
+}
+
+void UdpBasicOd3rApp::initialize(int stage)
+{
+    ClockUserModuleMixin::initialize(stage);
+
+    if (stage == INITSTAGE_LOCAL) {
+        // statistics setup
+        numSent = 0;
+        numReceivedAtLeastOnce = 0;
+        numReceivedOnBothPaths = 0;
+        numDuplicates = 0;
+        numOutOfOrder = 0;
+        numMissingPackets = 0;
+        numDeleted = 0;
+        WATCH(numSent);
+        WATCH(numReceivedAtLeastOnce);
+        WATCH(numReceivedOnBothPaths);
+        WATCH(numDuplicates);
+        WATCH(numOutOfOrder);
+        WATCH(numMissingPackets);
+        WATCH(numDeleted);
+
+        // parameter extraction
+        localPort = par("localPort");
+        destPort = par("destPort");
+        startTime = par("startTime");
+        stopTime = par("stopTime");
+        delayLimit = par("delayLimit");
+
+        if (stopTime >= CLOCKTIME_ZERO && stopTime < startTime) // control time validity
+            throw cRuntimeError("Invalid startTime/stopTime parameters");
+
+        nextSleep = startTime;
+        nextBurst = startTime;
+        nextPkt = startTime;
+
+        dontFragment = par("dontFragment");
+
+        messageLengthPar = &par("messageLength");
+        burstDurationPar = &par("burstDuration");
+        sleepDurationPar = &par("sleepDuration");
+        sendIntervalPar = &par("sendInterval");
+
+        redundantPacketDelivery = par("redundantPacketDelivery");
+
+        destAddrRNG = par("destAddrRNG");
+        const char *addrModeStr = par("chooseDestAddrMode");
+        int addrMode = cEnum::get("inet::ChooseDestAddrMode")->lookup(addrModeStr);
+        if (addrMode == -1)
+            throw cRuntimeError("Invalid chooseDestAddrMode: '%s'", addrModeStr);
+        chooseDestAddrMode = static_cast<ChooseDestAddrMode>(addrMode);
+
+
+        // create clock event for further use
+        selfMsg = new ClockEvent("sendTimer");
+    }
+}
+
+void UdpBasicOd3rApp::finish()
+{
+    // record statistics
+    if(packetOutDuplication) {
+        recordScalar("total packets sent", numSent*2);
+        recordScalar("unique packets sent", numSent);
+    }
+    else
+        recordScalar("total packets sent", numSent);
+    if(redundantPacketDelivery) {
+        recordScalar("packets received on both paths", numReceivedOnBothPaths);
+        recordScalar("packets received only once", numReceivedAtLeastOnce-numReceivedOnBothPaths);
+    }
+    recordScalar("unique packets received", numReceivedAtLeastOnce);
+    recordScalar("duplicate packets received", numDuplicates);
+    recordScalar("packets received out of seq order", numOutOfOrder);
+    recordScalar("packets missing", numMissingPackets);
+    recordScalar("packets deleted", numDeleted);
+
+    ApplicationBase::finish();
+}
+
+void UdpBasicOd3rApp::setSocketOptions()
+{
+    // set options for socket
+    int timeToLive = par("timeToLive");
+    if (timeToLive != -1)
+        socket.setTimeToLive(timeToLive);
+
+    int dscp = par("dscp");
+    if (dscp != -1)
+        socket.setDscp(dscp);
+
+    int tos = par("tos");
+    if (tos != -1)
+        socket.setTos(tos);
+
+    int disjointPathSelector = par("disjointPathSelector");
+    if (disjointPathSelector >= 0) {
+        packetOutDuplication = false;
+        if (disjointPathSelector == 256) {
+            packetOutDuplication = true;
+        }
+        else if (disjointPathSelector >= 2) {
+            throw cRuntimeError("Invalid path selector parameter");
+        }
+        socket.setDisjointPathRequest(disjointPathSelector);
+    }
+
+    socket.setCallback(this);
+}
+
+L3Address UdpBasicOd3rApp::chooseDestAddr()
+{
+    //  if multiple addresses are present, choose one accordingly
+    int k = 0;
+    if (destAddresses.size() > 1)
+        k = getRNG(destAddrRNG)->intRand(destAddresses.size());
+    if (!wildcardDest && (destAddresses[k].isUnspecified() || destAddresses[k].isLinkLocal())) { // TODO is this really needed?
+        int temp = 0;
+        auto it = destSequence.find(destAddresses[k]);
+        if (it != destSequence.end()) {
+            temp = it->second;
+            destSequence.erase(it);
+        }
+        L3AddressResolver().tryResolve(destAddressStr[k].c_str(), destAddresses[k]);
+        destSequence[destAddresses[k]] = temp;
+    }
+    return destAddresses[k];
+}
+
+Packet *UdpBasicOd3rApp::createPacket()
+{
+    // create the packet for sending
+    char msgName[32];
+    sprintf(msgName, "UDPBasicOd3rAppData-%d", counter++);
+    long msgByteLength = *messageLengthPar;
+    Packet *packet = new Packet(msgName);
+    if (dontFragment)
+           packet->addTag<FragmentationReq>()->setDontFragment(true);
+
+    const auto& payload = makeShared<ApplicationPacket>();
+    payload->setChunkLength(B(msgByteLength));
+    payload->setSequenceNumber(destSequence[destAddr]);
+    payload->addTag<CreationTimeTag>()->setCreationTime(simTime());
+    packet->insertAtBack(payload);
+    packet->addPar("sourceId") = getId();
+    packet->addPar("msgId") = destSequence[destAddr];
+    packet->setTimestamp();
+
+    destSequence[destAddr]++;
+
+    return packet;
+}
+
+void UdpBasicOd3rApp::sendPacket()
+{
+    // sending/emiting the packets
+    Packet* packet = createPacket();
+    emit(packetSentSignal, packet);
+    socket.sendTo(packet, destAddr, destPort);
+    numSent++;
+}
+
+void UdpBasicOd3rApp::generateBurst()
+{
+    clocktime_t now = getClockTime();
+
+    if (nextPkt < now)
+        nextPkt = now;
+
+    double sendInterval = *sendIntervalPar;
+    if (sendInterval <= 0.0)
+        throw cRuntimeError("The sendInterval parameter must be bigger than 0");
+    nextPkt += sendInterval;
+
+    if (activeBurst && nextBurst <= now) { // new burst
+        double burstDuration = *burstDurationPar;
+        if (burstDuration < 0.0)
+            throw cRuntimeError("The burstDuration parameter mustn't be smaller than 0");
+        double sleepDuration = *sleepDurationPar;
+
+        if (burstDuration == 0.0)
+            activeBurst = false;
+        else {
+            if (sleepDuration < 0.0)
+                throw cRuntimeError("The sleepDuration parameter mustn't be smaller than 0");
+            nextSleep = now + burstDuration;
+            nextBurst = nextSleep + sleepDuration;
+        }
+
+        if (chooseDestAddrMode == PER_BURST) {
+            destAddr = chooseDestAddr();
+        }
+    }
+
+    if (chooseDestAddrMode == PER_SEND){
+        destAddr = chooseDestAddr();
+    }
+
+    sendPacket();
+
+    // Next timer
+    if (activeBurst && nextPkt >= nextSleep)
+        nextPkt = nextBurst;
+
+    if (stopTime >= CLOCKTIME_ZERO && nextPkt >= stopTime) {
+        selfMsg->setKind(STOP);
+        nextPkt = stopTime;
+    }
+    scheduleClockEventAt(nextPkt, selfMsg);
+}
+
+void UdpBasicOd3rApp::processStart()
+{
+    socket.setOutputGate(gate("socketOut"));
+    const char *localAddress = par("localAddress");
+    socket.bind(*localAddress ? L3AddressResolver().resolve(localAddress) : L3Address(), localPort);
+    setSocketOptions();
+
+    const char *destAddrs = par("destAddresses");
+
+    bool excludeLocalDestAddresses = par("excludeLocalDestAddresses");
+
+    IInterfaceTable *ift = getModuleFromPar<IInterfaceTable>(par("interfaceTableModule"), this);
+
+    if (strcmp(destAddrs, "*") == 0) { // use wildcard to make life more easy
+        wildcardDest = true;
+        for (auto module: L3AddressResolver().collectNetworkNodes()) {
+            L3Address result = L3AddressResolver().addressOf(module);
+            if (result.isUnspecified())
+               EV_ERROR << "cannot resolve destination address: " << module->getClassAndFullPath() << endl;
+            if (excludeLocalDestAddresses && ift && ift->isLocalAddress(result))
+               continue;
+            destAddresses.push_back(result);
+            destSequence[result] = 0;
+        }
+
+    }
+    else {
+        cStringTokenizer tokenizer(destAddrs);
+        const char *token;
+
+        // mapping to addresses
+        while ((token = tokenizer.nextToken()) != nullptr) {
+            L3Address result;
+            L3AddressResolver().tryResolve(token, result);
+            if (result.isUnspecified())
+               EV_ERROR << "cannot resolve destination address: " << token << endl;
+            if (excludeLocalDestAddresses && ift && ift->isLocalAddress(result))
+               continue;
+            destAddressStr.push_back(token); // <--- TODO needed?
+            destAddresses.push_back(result);
+            destSequence[result] = 0;
+        }
+    }
+
+    // decide if source or only sink
+    isSource = !destAddresses.empty();
+
+    // update timers
+    nextSleep = getClockTime();
+    nextBurst = getClockTime();
+    nextPkt = getClockTime();
+    activeBurst = false;
+
+    // schedule next message
+    if (isSource) {
+        if (chooseDestAddrMode == ONCE)
+            destAddr = chooseDestAddr();
+
+        activeBurst = true;
+        selfMsg->setKind(SEND);
+        processSend();
+    }
+    else {
+        if (stopTime >= CLOCKTIME_ZERO) {
+            selfMsg->setKind(STOP);
+            scheduleClockEventAt(stopTime, selfMsg);
+        }
+    }
+}
+void UdpBasicOd3rApp::processStop()
+{
+    socket.close();
+    socket.setCallback(nullptr);
+}
+void UdpBasicOd3rApp::processSend()
+{
+    // send packet and schedule next
+    if (stopTime < CLOCKTIME_ZERO || getClockTime() < stopTime) {
+        // send and reschedule next sending
+        if (isSource) // if the node is a sink, don't generate messages
+            generateBurst();
+    }
+}
+void UdpBasicOd3rApp::processPacket(Packet *pk) // handle incomming packet
+{
+    if (pk->getKind() == UDP_I_ERROR) {
+        EV_WARN << "UDP error received\n";
+        delete pk;
+        return;
+    }
+
+    // check packet sequence number
+    if (pk->hasPar("sourceId") && pk->hasPar("msgId"))  {
+        int moduleId = pk->par("sourceId");
+        int msgId = pk->par("msgId");
+        // compare highest sequence number for this source with packet seqNo
+        auto it = sourceSequence.find(moduleId);
+        if (it != sourceSequence.end()) { // source is present => not the first packet from this source
+            if (it->second >= msgId) { // seqNo is smaller than highest seqNo for this source
+                // this is either: a) an out of order packet (closing a gap) or b) a duplicate packet
+                auto it1 = sourceSequenceMissing.find(moduleId);
+                if (it1 != sourceSequenceMissing.end() && it1->second.find(msgId) != it1->second.end()) { // check condition a)
+                    if (checkPacketLifeTime(pk)) {
+                        it1->second.erase(msgId); // remove from missing packet list -> this is intentionally only deleted if packet lifetime is met!
+                        handleOutOfOrderPacket(pk);
+                    }
+                    return;
+                }
+                else { // has to be a duplicate b)
+                    // this is either: a) intentional (due to redundant transmissions) or b) non intentional (packet duplication)
+                    if (redundantPacketDelivery) { // could be intentional
+                        // find in map
+                        auto it2 = sourceSequenceRedundancy.find(moduleId);
+                        if (it2 != sourceSequenceRedundancy.end()) { // if in map
+                            if (it2->second >= msgId) { // seqNo is smaller than highest seqNo for this source for redundant transmission
+                                // this is either: a) an out of order packet (closing a gap) or b) a duplicate packet
+                                auto it3 = sourceSequenceMissingRedundancy.find(moduleId);
+                                if (it3 != sourceSequenceMissingRedundancy.end() && it3->second.find(msgId) != it3->second.end()) { // check if packet closes gap
+                                    it3->second.erase(msgId); // we erase this no matter if the packet is in time or not further packets should be marked as duplicates!
+                                    // this would be out of order delivery, however for the redundant channel we don't care
+                                }
+                                else { // is duplicate
+                                    handleDuplicatePacket(pk);
+                                    return;
+                                }
+                            }
+                            else if (it2->second+1 == msgId) { // seqNo seamlesly fits in order to previously received redundant packet
+                                it2->second++;
+                            }
+                            else { // redundant transmission packets are missing
+                                for (int i = it->second;i<msgId;i++) {
+                                    sourceSequenceMissing[moduleId].insert(i); // add missing packets to list
+                                }
+                            }
+                        }
+                        else {
+                            sourceSequenceRedundancy[moduleId] = msgId; // add to map
+                        }
+                        if(checkPacketLifeTime(pk))
+                            handleReceivedRedundantPacket(pk);
+                        return;
+                    }
+                    else { // is not intentional
+                        handleDuplicatePacket(pk);
+                        return;
+                    }
+                }
+            }
+            else if (it->second+1 == msgId) { // seqNo seamlesly fits in order to previously received packets
+                it->second++;
+            }
+            else { // there is a gap indicating missing or at least delayed packets
+                for (int i = it->second;i<msgId;i++) {
+                    // add missing packets to list
+                    sourceSequenceMissing[moduleId].insert(i);
+                    numMissingPackets++;
+                }
+                it->second = msgId;
+            }
+        }
+        else {
+            sourceSequence[moduleId] = msgId; // add this source seqNo from packet as highest SeqNo
+        }
+    }
+
+    // Check if packets are to old
+    if(checkPacketLifeTime(pk))
+        handleReceivedPacket(pk);
+}
+
+bool UdpBasicOd3rApp::checkPacketLifeTime(Packet *pk)
+{
+    if (delayLimit > 0) {
+        if (simTime() - pk->getTimestamp() > delayLimit) {
+            EV_DEBUG << "Old packet: " << UdpSocket::getReceivedPacketInfo(pk) << endl;
+            PacketDropDetails details;
+            details.setReason(CONGESTION);
+            emit(packetDroppedSignal, pk, &details);
+            delete pk;
+            numDeleted++;
+            return false;
+        }
+    }
+    return true;
+}
+void UdpBasicOd3rApp::handleDuplicatePacket(Packet *pk)
+{
+    EV_DEBUG << "Duplicate packet: " << UdpSocket::getReceivedPacketInfo(pk) << endl;
+    PacketDropDetails details;
+    details.setReason(DUPLICATE_DETECTED);
+    emit(packetDroppedSignal, pk, &details);
+    delete pk;
+    numDeleted++;
+    numDuplicates++;
+}
+void UdpBasicOd3rApp::handleReceivedPacket(Packet *pk)
+{
+    EV_INFO << "Received packet: " << UdpSocket::getReceivedPacketInfo(pk) << endl;
+    emit(packetReceivedSignal, pk);
+    numReceivedAtLeastOnce++;
+    delete pk;
+}
+void UdpBasicOd3rApp::handleReceivedRedundantPacket(Packet *pk)
+{
+    EV_INFO << "Received redundant packet: " << UdpSocket::getReceivedPacketInfo(pk) << endl;
+    emit(redundantPkReceived, pk);
+    numReceivedOnBothPaths++;
+    delete pk;
+}
+void UdpBasicOd3rApp::handleOutOfOrderPacket(Packet *pk)
+{
+    EV_DEBUG << "Out of order packet: " << UdpSocket::getReceivedPacketInfo(pk) << endl;
+    emit(outOfOrderPk, pk);
+    numMissingPackets--;
+    numOutOfOrder++;
+    emit(packetReceivedSignal, pk);
+    numReceivedAtLeastOnce++;
+    delete pk;
+}
+
+
+
+void UdpBasicOd3rApp::refreshDisplay() const
+{
+    ApplicationBase::refreshDisplay();
+
+    char buf[100];
+    sprintf(buf, "rcvd: %d pks\nsent: %d pks", numReceivedAtLeastOnce, numSent);
+    getDisplayString().setTagArg("t", 0, buf);
+}
+
+void UdpBasicOd3rApp::handleMessageWhenUp(cMessage *msg)
+{
+    if (msg->isSelfMessage()) {
+        ASSERT(msg == selfMsg);
+        switch (selfMsg->getKind()) {
+            case START:
+                processStart();
+                break;
+
+            case SEND:
+                processSend();
+                break;
+
+            case STOP:
+                processStop();
+                break;
+
+            default:
+                throw cRuntimeError("Invalid kind %d in self message", (int)selfMsg->getKind());
+        }
+    }
+    else
+        socket.processMessage(msg);
+}
+
+void UdpBasicOd3rApp::handleStartOperation(LifecycleOperation *operation)
+{
+    clocktime_t start = std::max(startTime, getClockTime());
+    if ((stopTime < CLOCKTIME_ZERO) || (start < stopTime) || (start == stopTime && startTime == stopTime)) {
+        selfMsg->setKind(START);
+        scheduleClockEventAt(start, selfMsg);
+    }
+}
+void UdpBasicOd3rApp::handleStopOperation(LifecycleOperation *operation)
+{
+    if (selfMsg)
+        cancelEvent(selfMsg); // TODO: check if cancelEvent or cancelClockEvent
+    activeBurst = false;
+    socket.close();
+    delayActiveOperationFinish(par("stopOperationTimeout"));
+}
+void UdpBasicOd3rApp::handleCrashOperation(LifecycleOperation *operation)
+{
+    if (selfMsg)
+        cancelClockEvent(selfMsg); // TODO: check if cancelEvent or cancelClockEvent
+    activeBurst = false;
+    if (operation->getRootModule() != getContainingNode(this)) // closes socket when the application crashed only
+        socket.destroy(); // TODO  in real operating systems, program crash detected by OS and OS closes sockets of crashed programs.
+}
+
+void UdpBasicOd3rApp::socketDataArrived(UdpSocket *socket, Packet *packet)
+{
+    // process incoming packet
+    processPacket(packet);
+}
+
+void UdpBasicOd3rApp::socketErrorArrived(UdpSocket *socket, Indication *indication)
+{
+    EV_WARN << "Ignoring UDP error report " << indication->getName() << endl;
+    delete indication;
+}
+
+void UdpBasicOd3rApp::socketClosed(UdpSocket *socket)
+{
+    if (operationalState == State::STOPPING_OPERATION)
+        startActiveOperationExtraTimeOrFinish(par("stopOperationExtraTime"));
+}
+} /* namespace inet */
diff -Naur inet_orig/src/inet/applications/udpapp/UdpBasicOd3rApp.h inet_od3r/src/inet/applications/udpapp/UdpBasicOd3rApp.h
--- inet_orig/src/inet/applications/udpapp/UdpBasicOd3rApp.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/applications/udpapp/UdpBasicOd3rApp.h	2023-12-20 17:28:39.425267654 +0100
@@ -0,0 +1,146 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+//
+
+#ifndef INET_APPLICATIONS_UDPAPP_UDPBASICOD3RAPP_H_
+#define INET_APPLICATIONS_UDPAPP_UDPBASICOD3RAPP_H_
+
+#include <vector>
+
+#include "inet/applications/base/ApplicationBase.h"
+#include "inet/common/clock/ClockUserModuleMixin.h"
+#include "inet/transportlayer/contract/udp/UdpSocket.h"
+
+namespace inet {
+
+extern template class ClockUserModuleMixin<ApplicationBase>;
+/**
+ * Similar class to a mixture of UdpBasicApp and UdpBasicBurst. But allows handling packets using disjoint paths
+ */
+class INET_API UdpBasicOd3rApp : public ClockUserModuleMixin<ApplicationBase>, public UdpSocket::ICallback
+{
+public:
+    enum ChooseDestAddrMode {
+        ONCE = 1, PER_BURST, PER_SEND
+    };
+
+protected:
+    enum SelfMsgKinds { START = 1, SEND, STOP };
+    typedef std::map<int, int> SourceSequence;
+    typedef std::map<L3Address, int> DestSequenceNumber;
+    typedef std::map<int, std::set<int>> SourceMissingPackets;
+
+    // parameters
+    std::vector<L3Address> destAddresses;
+    std::vector<std::string> destAddressStr; // for what?
+    ChooseDestAddrMode chooseDestAddrMode = static_cast<ChooseDestAddrMode>(0);
+    int localPort = -1, destPort = -1;
+    int destAddrRNG = -1;
+    int thresholdSeqNumGap = -1;
+    clocktime_t startTime;
+    clocktime_t stopTime;
+    bool dontFragment = false;
+    // const char *packetName = nullptr; // for what?
+    bool redundantPacketDelivery = false;
+
+    simtime_t delayLimit;
+
+    // volatile parameters:
+    cPar *messageLengthPar = nullptr;
+    cPar *burstDurationPar = nullptr;
+    cPar *sleepDurationPar = nullptr;
+    cPar *sendIntervalPar = nullptr;
+
+
+    // state
+    UdpSocket socket;
+    ClockEvent *selfMsg = nullptr;
+    L3Address destAddr;
+    SourceSequence sourceSequence;
+    SourceMissingPackets sourceSequenceMissing;
+    SourceSequence sourceSequenceRedundancy;
+    SourceMissingPackets sourceSequenceMissingRedundancy;
+    DestSequenceNumber destSequence;
+    clocktime_t nextPkt;
+    clocktime_t nextBurst;
+    clocktime_t nextSleep;
+    bool packetOutDuplication = false;
+    bool activeBurst = false;
+    bool isSource = false;
+    bool wildcardDest = false;
+
+    // statistics
+    static int counter;
+
+    simsignal_t redundantPkReceived = registerSignal("redundantPkReceived");
+    simsignal_t outOfOrderPk = registerSignal("outOfOrderPk");
+
+
+    int numSent = 0;
+    int numReceivedAtLeastOnce = 0; // uniquely received on atleast one path
+    int numReceivedOnBothPaths = 0; // received on both paths
+    int numDuplicates = 0; // received more than two times
+    int numOutOfOrder = 0; // received outOfOrder
+    int numMissingPackets = 0; // missing Packets
+    int numDeleted = 0; // deleted packets due to too high delay
+
+
+protected:
+    virtual int numInitStages() const override { return NUM_INIT_STAGES; }
+    virtual void initialize(int stage) override;
+    virtual void finish() override;
+
+    virtual void setSocketOptions();
+    // chooses random destination address
+    virtual L3Address chooseDestAddr();
+    virtual Packet *createPacket();
+    virtual void sendPacket();
+    virtual void generateBurst();
+
+    virtual void processStart();
+    virtual void processStop();
+    virtual void processSend();
+    virtual void processPacket(Packet *msg);// Receive Packet
+
+    virtual bool checkPacketLifeTime(Packet *pk);
+    virtual void handleDuplicatePacket(Packet *pk);
+    virtual void handleReceivedPacket(Packet *pk);
+    virtual void handleReceivedRedundantPacket(Packet *pk);
+    virtual void handleOutOfOrderPacket(Packet *pk);
+
+    virtual void refreshDisplay() const override;
+
+    virtual void handleMessageWhenUp(cMessage *msg) override;
+
+    virtual void handleStartOperation(LifecycleOperation *operation) override;
+    virtual void handleStopOperation(LifecycleOperation *operation) override;
+    virtual void handleCrashOperation(LifecycleOperation *operation) override;
+
+    virtual void socketDataArrived(UdpSocket *socket, Packet *packet) override;
+    virtual void socketErrorArrived(UdpSocket *socket, Indication *indication) override;
+    virtual void socketClosed(UdpSocket *socket) override;
+
+
+
+public:
+    UdpBasicOd3rApp() {};
+    ~UdpBasicOd3rApp();
+
+};
+
+} /* namespace inet */
+
+#endif /* INET_APPLICATIONS_UDPAPP_UDPBASICOD3RAPP_H_ */
diff -Naur inet_orig/src/inet/applications/udpapp/UdpBasicOd3rApp.ned inet_od3r/src/inet/applications/udpapp/UdpBasicOd3rApp.ned
--- inet_orig/src/inet/applications/udpapp/UdpBasicOd3rApp.ned	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/applications/udpapp/UdpBasicOd3rApp.ned	2023-12-20 17:28:39.425267654 +0100
@@ -0,0 +1,77 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+package inet.applications.udpapp;
+
+import inet.applications.contract.IApp;
+
+// Similiar to a mixture of UdpBasicApp and UdpBasicBurstApp, but this supports redundant delivery and disjoint paths using OD3R.
+// Further, additional improvements have been made
+simple UdpBasicOd3rApp like IApp {
+     parameters:
+        string interfaceTableModule;   // The path to the InterfaceTable module
+        string clockModule = default(""); // relative path of a module that implements IClock; optional
+        
+        string localAddress = default("");
+        int localPort = default(-1);  // local port (-1: use ephemeral port)
+        
+        string destAddresses = default(""); // list of IP addresses, separated by spaces ("": don't send, "*" include all addresses)
+        int destPort;
+        bool excludeLocalDestAddresses = default(true);     // excluding local addresses from destAddresses
+        string chooseDestAddrMode @enum("once","perBurst","perSend") = default("once"); // when to change the destination address
+        int destAddrRNG = default(0); // random generator ID for selecting a destination address        
+        
+        double startTime @unit(s) = default(this.sendInterval); // application start time (start of the first packet)
+        double stopTime @unit(s) = default(-1s);  // time of finishing sending, -1s means forever
+        
+        volatile int messageLength @unit(B); // length of messages to generate, in bytes
+        volatile double burstDuration @unit(s); // burst duration time (zero not allowed)
+        volatile double sleepDuration @unit(s); // time between bursts (zero allowed)
+        volatile double sendInterval @unit(s); // time between messages during bursts; usually a random value, e.g. 0.1s+uniform(-0.001s,0.001s); zero not allowed
+        double delayLimit @unit(s) = default(0s); // maximum accepted delay for a packet; packets with a bigger delay are discarded (dropped), zero value means no limit
+       
+        int timeToLive = default(-1); // if not -1, set the TTL (IPv4) or Hop Limit (IPv6) field of sent packets to this value
+        bool dontFragment = default(false); // if true, asks IP to not fragment the message during routing
+        int dscp = default(-1); // if not -1, set the DSCP field (on IPv4/IPv6) of sent packets to this value
+        int tos = default(-1); // if not -1, set the Type Of Service (IPv4) / Traffic Class (IPv6) field of sent packets to this value
+        
+        bool redundantPacketDelivery = default(false);
+        int disjointPathSelector = default(-1);
+        
+        @display("i=block/app");
+        @lifecycleSupport;
+        double stopOperationExtraTime @unit(s) = default(-1s);    // extra time after lifecycle stop operation finished
+        double stopOperationTimeout @unit(s) = default(2s);    // timeout value for lifecycle stop operation
+        
+        @signal[packetSent](type=inet::Packet);
+        @signal[packetReceived](type=inet::Packet);
+        @signal[redundantPkReceived](type=inet::Packet);
+        @signal[packetDropped](type=inet::Packet);
+        @signal[outOfOrderPk](type=inet::Packet);
+        @statistic[packetSent](title="packets sent"; source=packetSent; record=count,"sum(packetBytes)","stats(packetBytes)"; interpolationmode=none);
+        @statistic[packetReceived](title="packets received"; source=packetReceived; record=count,"sum(packetBytes)","stats(packetBytes)"; interpolationmode=none);
+        @statistic[dropPk](title="packets dropped"; source=packetDropped; record=count,"sum(packetBytes)","stats(packetBytes)"; interpolationmode=none);
+        @statistic[outOfOrderPk](title="packets received out of order"; source=outOfOrderPk; record=count,"sum(packetBytes)","vector(packetBytes)"; interpolationmode=none);
+        @statistic[redundantPkReceived](title="packets received redundantly"; source=redundantPkReceived; record=count,"sum(packetBytes)","stats(packetBytes)"; interpolationmode=none);
+        @statistic[throughput](title="throughput"; unit=bps; source="throughput(packetReceived)"; record=stats, timeavg);
+        @statistic[rcvdPkLifetime](title="received packet lifetime"; source="dataAge(packetReceived)"; unit=s; record=histogram,vector, timeavg; interpolationmode=none);
+        @statistic[rcvdPkSeqNo](title="received packet sequence number"; source="appPkSeqNo(packetReceived)"; record=vector; interpolationmode=none);
+                
+    gates:
+        input socketIn @labels(UdpControlInfo/up);
+        output socketOut @labels(UdpControlInfo/down);
+}
diff -Naur inet_orig/src/inet/common/scenario/FailureGenerator.cc inet_od3r/src/inet/common/scenario/FailureGenerator.cc
--- inet_orig/src/inet/common/scenario/FailureGenerator.cc	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/common/scenario/FailureGenerator.cc	2023-12-20 17:28:39.438601202 +0100
@@ -0,0 +1,221 @@
+//
+//  Author: 2023 Konrad Altenhofen
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#include "FailureGenerator.h"
+
+namespace inet {
+
+Define_Module(FailureGenerator);
+
+FailureGenerator::~FailureGenerator() {
+    if (topology)
+        delete topology;
+    for (auto message: scheduledTimers)
+            cancelAndDelete(message);
+    scheduledTimers.clear();
+}
+void FailureGenerator::initialize()
+{
+    maxCurrentFailures = par("maxCurrentFailures");
+    maxNumFailures = par("maxNumFailures");
+    startAfter = par("startAfter");
+    linkSelectionRNG = par("linkSelectionRNG");
+
+    timeToRepair = &par("timeToRepair");
+    timeToFailure = &par("timeToFailure");
+
+    numTotalFailures = numTotalRepairs = currentFailures = 0;
+    WATCH(numTotalFailures);
+    WATCH(numTotalRepairs);
+    WATCH(currentFailures);
+
+    // set startAfterTimer
+    FailureGeneratorTimer *timerMsg = new FailureGeneratorTimer("FailureGenerator::FailureGeneratoreTimer");
+    scheduledTimers.push_back(timerMsg);
+    scheduleAfter(startAfter, timerMsg);
+
+}
+
+void FailureGenerator::handleMessage(cMessage *msg)
+{
+    FailureGeneratorTimer* timerMsg = check_and_cast<FailureGeneratorTimer *>(msg);
+
+    if (timerMsg->getType() == FailureGeneratorTimerType::INITIALIZE) {
+        // Handle Start After
+        // set and extract topology
+        initializeTopology();
+
+        // schedule failure message
+        FailureGeneratorFailureTimer *failureMsg = new FailureGeneratorFailureTimer("FailureGenerator::FailureGeneratorFailureTimer");
+        scheduledTimers.push_back(failureMsg);
+        scheduleAfter(*timeToFailure, failureMsg);
+
+        scheduledTimers.remove(timerMsg);
+        delete msg;
+    }
+    else if (timerMsg->getType() == FailureGeneratorTimerType::RepairTimer) {
+        // Handle Link Repair
+        FailureGeneratorRepairTimer* repairMsg = check_and_cast<FailureGeneratorRepairTimer *>(msg);
+        handleLinkRepair(repairMsg);
+    }
+    else if (timerMsg->getType() == FailureGeneratorTimerType::FailureTimer) {
+        // Handle Link Failure Message
+        if (maxNumFailures == -1 || numTotalFailures < maxNumFailures) { // check if the generator should continue
+            if (maxCurrentFailures == -1 || currentFailures < maxCurrentFailures) {
+                // create failure
+                // select link from toplogy
+                Topology::Link* link = selectRandomLink(); // How to select the node and then the link?
+                if (link) {
+                    // disconnect both sides, delete from topology and schedule repair
+                    handleLinkFailure(link);
+
+                    // update statictic counters
+                    ++currentFailures;
+                    ++numTotalFailures;
+                }
+                // no need to delete just reschedule
+            }
+            else {
+                //do nothing, reSchedule next failure after new time to failure
+            }
+            rescheduleAfter(*timeToFailure, msg);
+        }
+        else {
+            // done with failures, remove message from list
+            scheduledTimers.remove(timerMsg);
+            delete msg;
+        }
+    }
+
+}
+void FailureGenerator::initializeTopology() {
+    if (topology)
+        delete topology;
+    topology = new Topology();
+    topology->extractByProperty("networkRouter"); // I only want Routers
+}
+void FailureGenerator::handleLinkRepair(FailureGeneratorRepairTimer *msg) {
+    cGate* srcGate = msg->getSrcGateForUpdate();
+    cGate* destGate = msg->getDestGateForUpdate();
+    // get channel
+    cChannelType *channelType = msg->getChannelTypeForUpdate();
+
+    // connect srcGate and destGate via channel
+    createConnection(channelType, srcGate, destGate);
+
+    // add link to topology
+    topology->addLink(new Topology::Link(), srcGate, destGate);
+
+    // if was bidirectional do the same for the reverse direction
+    if (msg->isBidirectional() && srcGate->isGateHalf() && destGate->isGateHalf()) {
+        // connect in the other direction
+        createConnection(channelType, destGate->getOtherHalf(), srcGate->getOtherHalf());
+
+        // add link to topology
+        topology->addLink(new Topology::Link(), destGate->getOtherHalf(), srcGate->getOtherHalf());
+    }
+
+    // update statistic counters
+    ++numTotalRepairs;
+    --currentFailures;
+
+    // remove message from list
+    scheduledTimers.remove(msg);
+    delete msg;
+}
+void FailureGenerator::createConnection(cChannelType *channelType, cGate *srcGate, cGate *destGate)
+{
+    if (!channelType)
+        srcGate->connectTo(destGate);
+    else {
+        cChannel *channel = channelType->create("channel");
+
+        // connect:
+        srcGate->connectTo(destGate, channel);
+    }
+}
+void FailureGenerator::handleLinkFailure(Topology::Link* link) {
+    // get information from link
+    cGate* srcGate = link->getLinkOutLocalGate();
+    cGate* destGate = link->getLinkOutRemoteGate();
+
+    // if links are bidirectional connected, get other half as well
+    bool hasOtherHalf = srcGate->isGateHalf() && destGate->isGateHalf();
+    Topology::Link* reverseLink = hasOtherHalf ? getReverseLink(link) : nullptr;
+    hasOtherHalf = hasOtherHalf && reverseLink;
+
+    // create message
+    FailureGeneratorRepairTimer *failureMsg = new FailureGeneratorRepairTimer("FailureGenerator::FailureGeneratorRepairTimer");
+    failureMsg->setSrcGate(srcGate);
+    failureMsg->setDestGate(destGate);
+    failureMsg->setIsBidirectional(hasOtherHalf);
+    failureMsg->setChannelType(srcGate->getChannel()->getChannelType()); //FIXME
+    scheduledTimers.push_back(failureMsg);
+    scheduleAfter(*timeToRepair, failureMsg);
+
+    // disconnect
+    if (hasOtherHalf) destGate->getOtherHalf()->disconnect();
+    srcGate->disconnect();
+
+    // remove from topology
+    topology->deleteLink(link);
+    topology->deleteLink(reverseLink);
+}
+void FailureGenerator::refreshDisplay() const
+{
+    char buf[80];
+    if (maxNumFailures == -1)
+        sprintf(buf, "total %d failed links, %d currently", numTotalFailures, currentFailures);
+    else
+        sprintf(buf, "total %d failed links, %d left", numTotalFailures, maxNumFailures - numTotalFailures);
+    getDisplayString().setTagArg("t", 0, buf);
+}
+void FailureGenerator::finish() {
+    recordScalar("total failures", numTotalFailures);
+    recordScalar("total repairs", numTotalRepairs);
+    cSimpleModule::finish();
+}
+Topology::Link* FailureGenerator::selectRandomLink() {
+    if (topology->getNumNodes() == 0)
+        return nullptr;
+    int nodeIdx = getRNG(linkSelectionRNG)->intRand(topology->getNumNodes()); // get node index
+    Topology::Node* node = topology->getNode(nodeIdx);
+
+    if (node->getNumOutLinks() == 0) {
+        // what if no link is in node? -> reroll? but how often?
+        return nullptr;
+    }
+
+    int linkIdx = getRNG(linkSelectionRNG)->intRand(node->getNumOutLinks());// get link index
+    return node->getLinkOut(linkIdx);
+}
+Topology::Link* FailureGenerator::getReverseLink(Topology::Link* link) {
+    cGate* reverseLinkOutLocalGate = link->getLinkOutRemoteGate()->getOtherHalf();
+    Topology::Node *linkOutLocalNode = link->getLinkOutLocalNode();
+    cGate* reverseLinkOutRemoteGate = link->getLinkOutLocalGate()->getOtherHalf();
+    Topology::Node *linkOutRemoteNode = link->getLinkOutRemoteNode();
+    for (int i=0; i<linkOutRemoteNode->getNumOutLinks();i++) {
+        Topology::Link* candidate = linkOutRemoteNode->getLinkOut(i);
+        if (candidate->getLinkOutRemoteNode() == linkOutLocalNode
+                && candidate->getLinkOutLocalGate() == reverseLinkOutLocalGate
+                && candidate->getLinkOutRemoteGate() == reverseLinkOutRemoteGate)
+            return candidate;
+    }
+    return nullptr;
+}
+
+} /* namespace inet */
diff -Naur inet_orig/src/inet/common/scenario/FailureGenerator.h inet_od3r/src/inet/common/scenario/FailureGenerator.h
--- inet_orig/src/inet/common/scenario/FailureGenerator.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/common/scenario/FailureGenerator.h	2023-12-20 17:28:39.438601202 +0100
@@ -0,0 +1,75 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#ifndef INET_COMMON_SCENARIO_FAILUREGENERATOR_H_
+#define INET_COMMON_SCENARIO_FAILUREGENERATOR_H_
+
+#include "inet/common/lifecycle/LifecycleController.h"
+#include "inet/common/scenario/FailureGeneratorTimer_m.h"
+#include "inet/common/Topology.h"
+
+namespace inet {
+
+/**
+ * Enables creating random link failures and repairs.
+ * Is slightly oriented on the Scenario Manager, which however requires scripted events
+ */
+class INET_API FailureGenerator: public cSimpleModule, public LifecycleController {
+protected:
+    // total number of failures, repairs, and number of currently broken links
+    int numTotalFailures = 0;
+    int numTotalRepairs = 0;
+    int currentFailures = 0;
+
+    // state
+    Topology *topology = nullptr;
+    std::list<FailureGeneratorTimer*> scheduledTimers;
+
+    // parameter
+    int maxCurrentFailures= 1;
+    int maxNumFailures = -1;
+    int linkSelectionRNG = -1;
+    simtime_t startAfter = SIMTIME_ZERO;
+
+    // volataile parameters
+    cPar *timeToRepair = nullptr;
+    cPar *timeToFailure = nullptr;
+
+
+
+protected:
+    void initializeTopology();
+    void handleLinkRepair(FailureGeneratorRepairTimer *msg);
+    void createConnection(cChannelType *channelType, cGate *srcGate, cGate *destGate);
+    void handleLinkFailure(Topology::Link* link);
+    Topology::Link* selectRandomLink();
+    Topology::Link* getReverseLink(Topology::Link* link);
+//    void createConnection(const cXMLElementList& paramList, cChannelType *channelType, cGate *srcGate, cGate *destGate);
+public:
+    FailureGenerator() {}
+    virtual ~FailureGenerator();
+
+protected:
+    virtual void initialize() override;
+    virtual void handleMessage(cMessage *msg) override;
+    virtual void refreshDisplay() const override;
+    virtual void finish() override;
+};
+
+} /* namespace inet */
+
+#endif /* INET_COMMON_SCENARIO_FAILUREGENERATOR_H_ */
diff -Naur inet_orig/src/inet/common/scenario/FailureGenerator.ned inet_od3r/src/inet/common/scenario/FailureGenerator.ned
--- inet_orig/src/inet/common/scenario/FailureGenerator.ned	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/common/scenario/FailureGenerator.ned	2023-12-20 17:28:39.438601202 +0100
@@ -0,0 +1,36 @@
+//
+// Copyrigth (C) 2023 Konrad Altenhofen
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+package inet.common.scenario;
+
+//
+// Enables creating random link failures and repairs.
+// Is slightly inspired by the Scenario Manager, which however requires scripted events
+//
+simple FailureGenerator
+{
+    parameters:
+        int maxCurrentFailures = default(2); // limits the number of simulaneously failed links, 0 disables the generator, -1 means unlimeted
+        int maxNumFailures = default(-1); // limits the total number of link failures, 0 disables the generator, -1 means unlimeted
+        int linkSelectionRNG = default(0); // random generator which should be used for selecting links to break
+        double startAfter @unit(s) = default(0s); // time after which the generator starts
+        volatile double timeToRepair @unit(s) = default(3s); // time it takes to repair a link after it has failed
+        volatile double timeToFailure @unit(s) = default(2s); // time until a single link fail
+        //int ensureConnectivity = default(0); // unused atm
+        @display("i=block/network2");
+        
+}
diff -Naur inet_orig/src/inet/common/scenario/FailureGeneratorTimer.msg inet_od3r/src/inet/common/scenario/FailureGeneratorTimer.msg
--- inet_orig/src/inet/common/scenario/FailureGeneratorTimer.msg	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/common/scenario/FailureGeneratorTimer.msg	2023-12-20 17:28:39.438601202 +0100
@@ -0,0 +1,43 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+import inet.common.INETDefs;
+
+namespace inet;
+
+//
+// \Kal Timer messages for Failure Generator
+// Used for scheduled repairs, failures and initialize
+//
+enum FailureGeneratorTimerType
+{
+   INITIALIZE = 0;
+   FailureTimer = 1;
+   RepairTimer = 2;
+};
+message FailureGeneratorTimer {
+    FailureGeneratorTimerType type = INITIALIZE;
+}
+message FailureGeneratorFailureTimer extends FailureGeneratorTimer {
+    type = FailureTimer;
+}
+message FailureGeneratorRepairTimer extends FailureGeneratorTimer {
+    type = RepairTimer;
+    cGate* srcGate;
+    cGate* destGate;
+    bool isBidirectional = false;
+    cChannelType* channelType;
+}
diff -Naur inet_orig/src/inet/networklayer/common/DisjointPathTag.msg inet_od3r/src/inet/networklayer/common/DisjointPathTag.msg
--- inet_orig/src/inet/networklayer/common/DisjointPathTag.msg	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/common/DisjointPathTag.msg	2023-12-20 17:28:39.471935070 +0100
@@ -0,0 +1,26 @@
+// \KAL
+// for indication and request of disjoint Paths
+
+import inet.common.INETDefs;
+import inet.common.TagBase;
+
+namespace inet;
+
+class DisjointPathTagBase extends TagBase
+{
+    short pathSelector = -1;
+}
+
+//
+// Determines the initial hop count (time to live, ttl) for an outgoing packet.
+//
+class DisjointPathReq extends DisjointPathTagBase
+{
+}
+
+//
+// Specifies the remainder hop count (time to live, ttl) for an incoming packet.
+//
+class DisjointPathInd extends DisjointPathTagBase
+{
+}
diff -Naur inet_orig/src/inet/networklayer/contract/IRoute.h inet_od3r/src/inet/networklayer/contract/IRoute.h
--- inet_orig/src/inet/networklayer/contract/IRoute.h	2024-04-17 09:36:27.185393178 +0200
+++ inet_od3r/src/inet/networklayer/contract/IRoute.h	2023-12-20 17:28:39.475268457 +0100
@@ -39,7 +39,8 @@
         MANET2, ///< managed by manet, search approximate address
         DYMO, ///< managed by DYMO routing
         AODV, ///< managed by AODV routing
-        EIGRP, LISP, BABEL, ODR, UNKNOWN, ISIS
+        EIGRP, LISP, BABEL, ODR, UNKNOWN, ISIS,
+        OD3R_CALC, OD3R_SV ///< computed or via source route exchanged PathID routes
     };
 
     /** Field codes for NB_ROUTE_CHANGED notifications */
@@ -53,7 +54,11 @@
         F_ADMINDIST,
         F_METRIC,
         F_EXPIRYTIME,
-        F_LAST
+        F_LAST,
+        F_PATHID,
+        F_PATHSELECTOR,
+        F_DEFAULTROUTEMARKER,
+        F_FULLPATH // Check!? \KAL
     };
 
     /** Cisco like administrative distances */
diff -Naur inet_orig/src/inet/networklayer/ipv4/IIpv4RoutingTable.h inet_od3r/src/inet/networklayer/ipv4/IIpv4RoutingTable.h
--- inet_orig/src/inet/networklayer/ipv4/IIpv4RoutingTable.h	2024-04-17 09:36:27.185393178 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/IIpv4RoutingTable.h	2023-12-20 17:28:39.478601844 +0100
@@ -89,6 +89,12 @@
     using IRoutingTable::findBestMatchingRoute;
 
     /**
+     * \KAL
+     */
+    virtual Ipv4Route *findBestMatchingRoute(const Ipv4Address& dest, uint32_t pathId) const = 0;
+    virtual Ipv4Route *findBestMatchingInRoute(const Ipv4Address& dest, const uint8_t pathSelector) const = 0;
+
+    /**
      * Convenience function based on findBestMatchingRoute().
      *
      * Returns the output interface for the packets with dest as destination
@@ -145,6 +151,12 @@
     using IRoutingTable::addRoute;
 
     /**
+     * \KAL add Route if new
+     * Adds the route to the routing table, if it is not already present in the routing table
+     */
+    virtual Ipv4Route *addRouteIfNew(Ipv4Route *entry) = 0;
+
+    /**
      * Removes the given route from the routing table, and returns it.
      * nullptr is returned of the route was not in the routing table.
      */
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4.cc inet_od3r/src/inet/networklayer/ipv4/Ipv4.cc
--- inet_orig/src/inet/networklayer/ipv4/Ipv4.cc	2024-04-17 09:36:27.188726540 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4.cc	2023-12-20 17:28:39.481935231 +0100
@@ -10,6 +10,12 @@
 
 #include <stdlib.h>
 #include <string.h>
+// \KAL
+#include <queue>
+#include <inet/networklayer/ipv4/Ipv4PathIdRoute.h>
+#include "inet/networklayer/ipv4/Ipv4InputPathRoute.h"
+#include "inet/networklayer/od3r/Od3r.h"
+
 
 #include "inet/common/INETUtils.h"
 #include "inet/common/IProtocolRegistrationListener.h"
@@ -41,6 +47,8 @@
 #include "inet/networklayer/ipv4/Ipv4Header_m.h"
 #include "inet/networklayer/ipv4/Ipv4InterfaceData.h"
 #include "inet/networklayer/ipv4/Ipv4OptionsTag_m.h"
+#include "inet/networklayer/common/DisjointPathTag_m.h" // \KAL
+
 
 namespace inet {
 
@@ -71,6 +79,8 @@
         arp.reference(this, "arpModule", true);
         icmp.reference(this, "icmpModule", true);
 
+        od3r.reference(this, "od3rModule", false); // \KAL
+
         transportInGateBaseId = gateBaseId("transportIn");
 
         const char *crcModeString = par("crcMode");
@@ -414,21 +424,136 @@
         datagramLocalOut(packet);
 }
 
+// \KAL SOURCE ROUTING FOR config
+void Ipv4::setIpOptionOnNetworkDatagram(Packet *packet, Ipv4Option *ipOption)
+{
+    auto ipv4Header = removeNetworkProtocolHeader<Ipv4Header>(packet);
+    ipOption->setType(ipOption->getType());
+    B oldHlen = ipv4Header->calculateHeaderByteLength();
+    ASSERT(ipv4Header->getHeaderLength() == oldHlen);
+    ipv4Header->addOption(ipOption);
+    B newHlen = ipv4Header->calculateHeaderByteLength();
+    ipv4Header->setHeaderLength(newHlen);
+    ipv4Header->addChunkLength(newHlen - oldHlen);
+    ipv4Header->setTotalLengthField(ipv4Header->getTotalLengthField() + newHlen - oldHlen);
+    insertNetworkProtocolHeader(packet, Protocol::ipv4, ipv4Header);
+}
+
+// \KAL
+void Ipv4::updateIpv4OptionRecordRoute(Packet *packet)
+{
+    const auto& ipv4Header = removeNetworkProtocolHeader<Ipv4Header>(packet);
+    Ipv4OptionRecordRoute* sourceRouteTLV = check_and_cast_nullable<Ipv4OptionRecordRoute *>(ipv4Header->findMutableOptionByType(IPOPTION_EXCHANGE_SOURCE_ROUTE));
+    if (sourceRouteTLV) {
+        EV_DETAIL << "increasing the index in source route option"  << "\n";
+        sourceRouteTLV->setNextAddressIdx(sourceRouteTLV->getNextAddressIdx() + 1);
+    }
+    ASSERT2(sourceRouteTLV, "Expected a source route TLV to present in the packet, in order to increment the index by one");
+    insertNetworkProtocolHeader(packet, Protocol::ipv4, ipv4Header);
+}
+
+// \KAL
+void Ipv4::updateIpv4OptionResiudalPathId(Packet *packet, uint32_t packetId)
+{
+    const auto& ipv4Header = removeNetworkProtocolHeader<Ipv4Header>(packet);
+    Ipv4OptionRedisualPathId* resiudalPathTLV = check_and_cast_nullable<Ipv4OptionRedisualPathId *>(ipv4Header->findMutableOptionByType(IPOPTION_RESIDUAL_PATH_ID));
+    if (resiudalPathTLV) {
+        EV_DETAIL << "replacing the residual Path ID:" << packetId << "\n";
+        resiudalPathTLV->setPathIdentifier(packetId);
+    }
+    ASSERT2(resiudalPathTLV, "Expected a residual path id TLV to present in the packet, in order to update the packet Id");
+    insertNetworkProtocolHeader(packet, Protocol::ipv4, ipv4Header);
+}
+
+// \KAL
+void Ipv4::padIpOptionsOnNetworkDatagram(Packet *packet) {
+    auto ipv4Header = removeNetworkProtocolHeader<Ipv4Header>(packet);
+    B oldHlen = ipv4Header->calculateHeaderByteLength();
+    while (ipv4Header->getOptions().getLength() % 4 > 1) {
+            ipv4Header->addOption(new Ipv4OptionNop());
+    }
+    if(ipv4Header->getOptions().getLength() % 4 != 0) {
+        ipv4Header->addOption(new Ipv4OptionEnd());
+    }
+    B newHlen = ipv4Header->calculateHeaderByteLength();
+    ipv4Header->setHeaderLength(newHlen);
+    ipv4Header->addChunkLength(newHlen - oldHlen);
+    ipv4Header->setTotalLengthField(ipv4Header->getTotalLengthField() + newHlen - oldHlen);
+    insertNetworkProtocolHeader(packet, Protocol::ipv4, ipv4Header);
+}
+// \KAL
+void Ipv4::replaceRequestPathOption(Packet *packet, Ipv4Option* replaceTLV) {
+    EV_DETAIL << "replacing the request path option" << "\n";
+    auto ipv4Header = removeNetworkProtocolHeader<Ipv4Header>(packet);
+    auto & tlvOptions = ipv4Header->getOptionsForUpdate();
+
+    B oldHlen = ipv4Header->calculateHeaderByteLength();
+
+    tlvOptions.deleteOptionByType(IPOPTION_REQUEST_DISJOINT_PATH, 1);
+    tlvOptions.deleteOptionByType(IPOPTION_RESIDUAL_PATH_ID, 1);
+    tlvOptions.deleteOptionByType(IPOPTION_EXCHANGE_SOURCE_ROUTE, 1);
+    tlvOptions.deleteOptionByType(IPOPTION_REQUEST_DISJOINT_PATH, 1);
+    tlvOptions.deleteOptionByType(IPOPTION_NO_OPTION, 0);
+    tlvOptions.deleteOptionByType(IPOPTION_END_OF_OPTIONS, 1);
+
+    if (replaceTLV)
+        tlvOptions.appendTlvOption(replaceTLV);
+
+    ipv4Header->setOptions(tlvOptions);
+
+    while (ipv4Header->getOptions().getLength() % 4 > 1) {
+           ipv4Header->addOption(new Ipv4OptionNop());
+    }
+    if(ipv4Header->getOptions().getLength() % 4 != 0) {
+       ipv4Header->addOption(new Ipv4OptionEnd());
+    }
+    B newHlen = ipv4Header->calculateHeaderByteLength();
+    ipv4Header->setHeaderLength(newHlen);
+    ipv4Header->addChunkLength(newHlen - oldHlen);
+    ipv4Header->setTotalLengthField(ipv4Header->getTotalLengthField() + newHlen - oldHlen);
+    insertNetworkProtocolHeader(packet, Protocol::ipv4, ipv4Header);
+}
+// \KAL
+Ipv4OptionRecordRoute* Ipv4::createSourceRouteOption(std::stack<Ipv4Address> addrPath) {
+    Ipv4OptionRecordRoute* sourceRoute = new Ipv4OptionRecordRoute();
+    sourceRoute->setType(IPOPTION_EXCHANGE_SOURCE_ROUTE);
+    sourceRoute->setNextAddressIdx(0);
+    sourceRoute->setLength(3 + (addrPath.size()-1) * 4);
+    if (!addrPath.empty()) addrPath.pop(); // ignore first
+    while(!addrPath.empty()) {
+        sourceRoute->appendRecordAddress(addrPath.top());
+        addrPath.pop();
+    }
+    return sourceRoute;
+}
+// \KAL
+Ipv4OptionRecordRoute* Ipv4::createSourceRouteOptionViaVector(const std::vector<Ipv4Address>& addrPath) {
+    Ipv4OptionRecordRoute* sourceRoute = new Ipv4OptionRecordRoute();
+    sourceRoute->setType(IPOPTION_EXCHANGE_SOURCE_ROUTE);
+    sourceRoute->setNextAddressIdx(0);
+    sourceRoute->setLength(3 + (addrPath.size()-1) * 4);
+    bool first = true; // ignore first entry
+    for (auto & addr: addrPath) {
+        if (!first) sourceRoute->appendRecordAddress(addr); // we do not want the first entry in the source route option
+        else first = false;
+    }
+    return sourceRoute;
+}
+
 void Ipv4::datagramLocalOut(Packet *packet)
 {
+    const auto& ipv4Header = packet->peekAtFront<Ipv4Header>();
+    Ipv4Address destAddr = ipv4Header->getDestAddress();
+
     const NetworkInterface *destIE = getDestInterface(packet);
     Ipv4Address requestedNextHopAddress = getNextHop(packet);
 
-    const auto& ipv4Header = packet->peekAtFront<Ipv4Header>();
     bool multicastLoop = false;
     const auto& mcr = packet->findTag<MulticastReq>();
     if (mcr != nullptr) {
         multicastLoop = mcr->getMulticastLoop();
     }
 
-    // send
-    Ipv4Address destAddr = ipv4Header->getDestAddress();
-
     EV_DETAIL << "Sending datagram '" << packet->getName() << "' with destination = " << destAddr << "\n";
 
     if (ipv4Header->getDestAddress().isMulticast()) {
@@ -520,16 +645,182 @@
     return ie;
 }
 
+
+void Ipv4::setRoutingTagsForPacket(Packet* packet, const NetworkInterface *destIE, Ipv4Address sourceNextHopAddr) {
+    packet->addTagIfAbsent<InterfaceReq>()->setInterfaceId(destIE->getInterfaceId());
+    packet->addTagIfAbsent<NextHopAddressReq>()->setNextHopAddress(sourceNextHopAddr);
+}
+
 void Ipv4::routeUnicastPacket(Packet *packet)
 {
-    const NetworkInterface *fromIE = getSourceInterface(packet);
+    //const NetworkInterface *fromIE = getSourceInterface(packet);
     const NetworkInterface *destIE = getDestInterface(packet);
-    Ipv4Address nextHopAddress = getNextHop(packet);
+    //Ipv4Address nextHopAddress = getNextHop(packet);
 
     const auto& ipv4Header = packet->peekAtFront<Ipv4Header>();
     Ipv4Address destAddr = ipv4Header->getDestAddress();
     EV_INFO << "Routing " << packet << " with destination = " << destAddr << ", ";
 
+
+    // \KAL
+    if (rt->isForwardingEnabled()) { // Only Routers should care
+        const Ipv4OptionRequestDisjointPath* requestPathTlv = nullptr;
+        requestPathTlv = check_and_cast_nullable<const Ipv4OptionRequestDisjointPath *>(ipv4Header->findOptionByType(IPOPTION_REQUEST_DISJOINT_PATH));
+        if (requestPathTlv) { // Check if path request is present
+            od3r->noticeResidualPathRequest();
+            EV_INFO << "requesting disjoint paths" << "," << "\n";
+            Ipv4InputPathRoute* re = check_and_cast_nullable<Ipv4InputPathRoute*>(rt->findBestMatchingInRoute(destAddr, requestPathTlv->getPathSelector()));
+            if (re && re->isValid()) { // Check if path is already calculated and topology not changed
+                if (!re->isDefaultPathDummy()) { // if path is too long or graph is not 2 connected don't use the entry
+                    destIE = re->getInterface();
+                    packet->addTagIfAbsent<InterfaceReq>()->setInterfaceId(destIE->getInterfaceId());
+                    Ipv4Address sourceNextHopAddr = re->getGateway();
+                    packet->addTagIfAbsent<NextHopAddressReq>()->setNextHopAddress(sourceNextHopAddr);
+                    if (re->needsRefresh()) {
+                        Ipv4OptionRecordRoute* sourceRouteOption = createSourceRouteOptionViaVector(re->getFullAddrPath());
+                        replaceRequestPathOption(packet, sourceRouteOption);
+                        re->updateLastPathRefresh();
+
+                        od3r->noticeInitiateSRExchange(sourceRouteOption->getLength());
+                    }
+                    else { // no refresh required just use PID route
+                        Ipv4OptionRedisualPathId* residualPathTlv = new Ipv4OptionRedisualPathId();
+                        residualPathTlv->setPathIdentifier(re->getOutPathId());
+                        od3r->noticePathIdRequestReplace();
+                        replaceRequestPathOption(packet, residualPathTlv);
+                    }
+                }
+                else {
+                    replaceRequestPathOption(packet, nullptr);
+                    od3r->noticeDefaultPathDummyUse();
+                }
+                // Reset path entry decay timer
+                od3r->refreshRouteEntry(re);
+            }
+            else  { // No path cached: calculate path and add to internal table
+                if (!re) { // Check if no re is present, it may be in soft delete state but then computing disjoint path would not yield any new information
+                    std::pair<std::stack<Ipv4Address>, std::stack<Ipv4Address>> paths = od3r->computeDisjointPaths(destAddr);
+                    od3r->addInputRouteEntrys(destAddr, paths, requestPathTlv->getPathSelector());
+                    Ipv4InputPathRoute* reNew = check_and_cast_nullable<Ipv4InputPathRoute*>(rt->findBestMatchingInRoute(destAddr, requestPathTlv->getPathSelector()));
+                    if (reNew && !reNew->isDefaultPathDummy()) {
+                        Ipv4OptionRecordRoute* sourceRouteOption = createSourceRouteOptionViaVector(reNew->getFullAddrPath());
+                        replaceRequestPathOption(packet, sourceRouteOption);
+
+                        destIE = reNew->getInterface();
+                        packet->addTagIfAbsent<InterfaceReq>()->setInterfaceId(destIE->getInterfaceId());
+                        Ipv4Address sourceNextHopAddr = reNew->getGateway();
+                        packet->addTagIfAbsent<NextHopAddressReq>()->setNextHopAddress(sourceNextHopAddr);
+
+                        od3r->noticeInitiateSRExchange(sourceRouteOption->getLength());
+                    }
+    //                if (od3r->checkDisjointPathPairIfUseable(paths)) { // FIXME update code to same structure as above
+    //                    if (requestPathTlv->getPathSelector() == 1)
+    //                        sourceRouteOption = createSourceRouteOption(paths.second);
+    //                    else
+    //                        sourceRouteOption = createSourceRouteOption(paths.first);
+    //
+    //                    Ipv4Address sourceNextHopAddr = (requestPathTlv->getPathSelector() == 1) ?  paths.second.top() :
+    //                                                                                                paths.first.top();
+    //                    //sourceRouteOption->setNextAddressIdx(1);
+    //                    replaceRequestPathOption(packet, sourceRouteOption);
+    //
+    //                    od3r->noticeInitiateSRExchange(sourceRouteOption->getLength());
+    //
+    //                    const Ipv4Route *re = rt->findBestMatchingRoute(sourceNextHopAddr); // Better way to interface?
+    //                    if (re) {
+    //                        destIE = re->getInterface();
+    //                        packet->addTagIfAbsent<InterfaceReq>()->setInterfaceId(destIE->getInterfaceId());
+    //                        ASSERT2(re->getGateway().isUnspecified() || sourceNextHopAddr == re->getGateway(), "SourceNextHop does not equal the gateway");
+    //                        sourceNextHopAddr = re->getGateway().isUnspecified() ? sourceNextHopAddr : re->getGateway(); // check if needed, should be already set?
+    //                        packet->addTagIfAbsent<NextHopAddressReq>()->setNextHopAddress(sourceNextHopAddr);
+    //                    }
+    //                    else {
+    //                        od3r->noticeMissingDefaultRoute();
+    //                    }
+    //                }
+                    else {
+                        // replace here?
+                        replaceRequestPathOption(packet, nullptr);
+                        od3r->noticeDefaultPathDummyUse();
+                    }
+                }
+                else {
+                    // replace here?
+                    replaceRequestPathOption(packet, nullptr);
+                    od3r->noticePathInSoftDelete();
+                }
+            }
+        }
+        else {
+        // continue and check for source route
+        // \KAL Custom Source Route (DIFFERS FROM RFC!):
+        // a) Destination is NOT set to the new target!
+        // b) Route is NOT recorded; only the pointer is moved!
+        // c) Assume Source Routed Packets to be neither broadcast nor multicast
+        const Ipv4OptionRecordRoute* sourceRouteTLV = nullptr;
+        sourceRouteTLV = check_and_cast_nullable<const Ipv4OptionRecordRoute *>(ipv4Header->findOptionByType(IPOPTION_EXCHANGE_SOURCE_ROUTE));
+        if (sourceRouteTLV) {
+            od3r->noticeSourceRouteExchange();
+            EV_INFO << "with source route option" << "," << "\n";
+            short nextAddrIdx = sourceRouteTLV->getNextAddressIdx();
+            short remainingAddrIdx =  ((sourceRouteTLV->getLength() - 3) >> 2) - nextAddrIdx;
+            ASSERT(((4 + (nextAddrIdx << 2))  < sourceRouteTLV->getLength()) == (remainingAddrIdx > 0));
+            if (remainingAddrIdx > 0) { // Assure that Pointer does not point outside of the TLV
+                Ipv4Address sourceNextHopAddr = sourceRouteTLV->getRecordAddress(nextAddrIdx);
+                updateIpv4OptionRecordRoute(packet);
+
+                const Ipv4Route *re = rt->findBestMatchingRoute(sourceNextHopAddr); // TODO: Better way to interface?
+                if (re) {
+                    destIE = re->getInterface();
+                    packet->addTagIfAbsent<InterfaceReq>()->setInterfaceId(destIE->getInterfaceId());
+                    ASSERT2(re->getGateway().isUnspecified() || sourceNextHopAddr == re->getGateway(), "SourceNextHop does not equal the gateway");
+                    sourceNextHopAddr = re->getGateway().isUnspecified() ? sourceNextHopAddr : re->getGateway(); // TODO check if needed, should be already set?
+                    packet->addTagIfAbsent<NextHopAddressReq>()->setNextHopAddress(sourceNextHopAddr);
+                    // create new route in routing table
+                    od3r->addPathIdRouteEntry(*destIE, destAddr, *sourceRouteTLV, sourceNextHopAddr);
+                }
+                else {
+                    od3r->noticeMissingDefaultRoute();
+                }
+            }
+            else {
+                // replace here?
+                replaceRequestPathOption(packet, nullptr); // no more entries remove for traffic + security reasons
+            }
+        }
+        else { // no source route -> check if tagged with path id option
+            const Ipv4OptionRedisualPathId* residualPathIdTLV = nullptr;
+            residualPathIdTLV = check_and_cast_nullable<const Ipv4OptionRedisualPathId *>(ipv4Header->findOptionByType(IPOPTION_RESIDUAL_PATH_ID));
+            if (residualPathIdTLV) {
+                od3r->noticeResidualPathPacket();
+                EV_INFO << "with residual path tag" << "," << "\n";
+                if(residualPathIdTLV->getPathIdentifier() == 0)  {// in this case the current router is the last hop -> normal forwarding
+                    replaceRequestPathOption(packet, nullptr); // remove for security and overhead
+                }
+                else {
+                    Ipv4PathIdRoute *re = check_and_cast_nullable<Ipv4PathIdRoute *>(rt->findBestMatchingRoute(destAddr, residualPathIdTLV->getPathIdentifier()));
+                    if (re) {
+                        updateIpv4OptionResiudalPathId(packet, re->getOutPathId());
+                        destIE = re->getInterface();
+                        packet->addTagIfAbsent<InterfaceReq>()->setInterfaceId(destIE->getInterfaceId());
+                        packet->addTagIfAbsent<NextHopAddressReq>()->setNextHopAddress(re->getGateway());
+                        // Reset path entry decay timer
+                        od3r->refreshRouteEntry(re);
+                    }
+                    else {
+                        od3r->noticeMissingPidRoute();
+                        replaceRequestPathOption(packet, nullptr); // remove to ensure default path routing
+                    }
+                }
+            }
+        }
+    }
+    }
+    // \KAL)
+
+    const NetworkInterface *fromIE = getSourceInterface(packet);
+    Ipv4Address nextHopAddress = getNextHop(packet);
+
     // if output port was explicitly requested, use that, otherwise use Ipv4 routing
     if (destIE) {
         EV_DETAIL << "using manually specified output interface " << destIE->getInterfaceName() << "\n";
@@ -1022,6 +1313,21 @@
         ttl = defaultTimeToLive;
     ipv4Header->setTimeToLive(ttl);
 
+    // Adding the path request option to the routed packet \KAL
+    if (auto& disjointPathReq = transportPacket->removeTagIfPresent<DisjointPathReq>()) {
+        auto* disjointPathReqOption = new Ipv4OptionRequestDisjointPath();
+        disjointPathReqOption->setPathSelector(disjointPathReq->getPathSelector());
+        ipv4Header->addOption(disjointPathReqOption);
+
+        while (ipv4Header->getOptions().getLength() % 4 > 1) {
+               ipv4Header->addOption(new Ipv4OptionNop());
+        }
+        if(ipv4Header->getOptions().getLength() % 4 != 0) {
+           ipv4Header->addOption(new Ipv4OptionEnd());
+        }
+    }
+
+
     if (auto& optReq = transportPacket->removeTagIfPresent<Ipv4OptionsReq>()) {
         for (size_t i = 0; i < optReq->getOptionArraySize(); i++) {
             auto opt = optReq->removeOption(i);
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4.h inet_od3r/src/inet/networklayer/ipv4/Ipv4.h
--- inet_orig/src/inet/networklayer/ipv4/Ipv4.h	2024-04-17 09:36:27.188726540 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4.h	2023-12-20 17:28:39.481935231 +0100
@@ -12,6 +12,8 @@
 #include <list>
 #include <map>
 #include <set>
+// \KAL
+#include <stack>
 
 #include "inet/common/IProtocolRegistrationListener.h"
 #include "inet/common/lifecycle/ModuleOperations.h"
@@ -24,12 +26,17 @@
 #include "inet/networklayer/ipv4/Ipv4FragBuf.h"
 #include "inet/networklayer/ipv4/Ipv4Header_m.h"
 
+// \KAL
+#include "inet/common/Topology.h"
+
 namespace inet {
 
 class ArpPacket;
 class IcmpHeader;
 class IInterfaceTable;
 class IIpv4RoutingTable;
+// \KAL
+class Od3r;
 
 /**
  * Implements the Ipv4 protocol.
@@ -66,6 +73,7 @@
     ModuleRefByPar<IInterfaceTable> ift;
     ModuleRefByPar<IArp> arp;
     ModuleRefByPar<Icmp> icmp;
+    ModuleRefByPar<Od3r> od3r; // \KAL
     int transportInGateBaseId = -1;
 
     // config
@@ -143,6 +151,51 @@
     // called after PREROUTING Hook (used for reinject, too)
     virtual void preroutingFinish(Packet *packet);
 
+    // \KAL OD3R methods below
+    /**
+     * Add the ipOption to the packet header. Packet lengths are updated accordingly
+     * This function replaces the header by popping and reinserting a new Ip header
+     */
+    virtual void setIpOptionOnNetworkDatagram(Packet *packet, Ipv4Option *ipOption);
+    /**
+     * Increments next index address entry in the record option of a packet by one
+     * This function replaces the header by popping and reinserting a new Ip header
+     */
+    virtual void updateIpv4OptionRecordRoute(Packet *packet);
+    /**
+     * Changes the residual path id in the residual path id option of a packet
+     * This function replaces the header by popping and reinserting a new Ip header
+     */
+    virtual void updateIpv4OptionResiudalPathId(Packet *packet, uint32_t packetId);
+
+
+    /**
+     * Fill the Ip header with NOPs and and End Option, in a way, that the length of the option TLV is a multiple of four
+     * This function replaces the header by popping and reinserting a new Ip header
+     */
+    virtual void padIpOptionsOnNetworkDatagram(Packet *packet);
+    /**
+     * Removes all requiest path options, nop options and end options in the packet header and than adds the replaceTLV
+     * In addition the Option is padded afterwards
+     * This function replaces the header by popping and reinserting a new Ip header
+     */
+    virtual void replaceRequestPathOption(Packet *packet, Ipv4Option* replaceTLV);
+
+    /**
+     * Creates a source route TLV and adds all entries from the stack input
+     */
+    virtual Ipv4OptionRecordRoute* createSourceRouteOption(std::stack<Ipv4Address> addrPath);
+    /**
+     * Creates a source route TLV and adds all entries from the vector input
+     */
+    virtual Ipv4OptionRecordRoute* createSourceRouteOptionViaVector(const std::vector<Ipv4Address>& addrPath);
+
+    /**
+     * Adds tags for packet
+     */
+    virtual void setRoutingTagsForPacket(Packet* packet, const NetworkInterface *destIE, Ipv4Address sourceNextHopAddr);
+    // \KAL OD3R methods end
+
     /**
      * Handle messages (typically packets to be send in Ipv4) from transport or ICMP.
      * Invokes encapsulate(), then routePacket().
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4Header.msg inet_od3r/src/inet/networklayer/ipv4/Ipv4Header.msg
--- inet_orig/src/inet/networklayer/ipv4/Ipv4Header.msg	2024-04-17 09:36:27.188726540 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4Header.msg	2023-12-20 17:28:39.481935231 +0100
@@ -66,6 +66,17 @@
     IPOPTION_ROUTER_ALERT = 148;
 
     IPOPTION_TLV_GPSR = 47;
+    
+    // Use different Option Type for not messing with existing Implementations
+    // --> Use either another class (i.e. 1/3), overwrite a existing number (e.g. 4/10),
+    // which has another copy parameter/class, use unused number (26-29, 31) or EXP number
+    // --> use unused numbers
+    // \KAL option for Tag/Hash
+    IPOPTION_RESIDUAL_PATH_ID = 154;
+    // \KAL option for request of disjoint paths
+    IPOPTION_REQUEST_DISJOINT_PATH = 155;
+    // \KAL option for exchanging a computed path
+    IPOPTION_EXCHANGE_SOURCE_ROUTE = 156;
 };
 
 //
@@ -146,6 +157,27 @@
     uint16_t routerAlert = 0;
 }
 
+//
+// Option Structure: Residual Path ID
+// \KAL WIP for Tag/Hash
+//
+class Ipv4OptionRedisualPathId extends Ipv4Option
+{
+	type = IPOPTION_RESIDUAL_PATH_ID;
+	length = 6;
+	uint32_t pathIdentifier = 0;
+}
+
+//
+// Option Structure: Request disjoint paths
+//
+class Ipv4OptionRequestDisjointPath extends Ipv4Option
+{
+	type = IPOPTION_REQUEST_DISJOINT_PATH;
+	length = 3;
+	uint8_t pathSelector = 0;
+}
+
 class Ipv4OptionUnknown extends Ipv4Option
 {
     // type = any
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4InputPathRoute.cc inet_od3r/src/inet/networklayer/ipv4/Ipv4InputPathRoute.cc
--- inet_orig/src/inet/networklayer/ipv4/Ipv4InputPathRoute.cc	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4InputPathRoute.cc	2023-12-20 17:28:39.481935231 +0100
@@ -0,0 +1,112 @@
+//
+//  Author: 2023 Konrad Altenhofen
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#include "Ipv4InputPathRoute.h"
+
+namespace inet {
+bool Ipv4InputPathRoute::equals(const Ipv4InputPathRoute& route) const
+{
+    return Ipv4Route::equals(route) && pathSelector == route.pathSelector
+            && outPathId == route.outPathId && fullAddrPath == route.getFullAddrPath() && defaultPathDummy == route.isDefaultPathDummy();
+}
+
+bool Ipv4InputPathRoute::equalsWithoutRT(const Ipv4InputPathRoute& route) const
+{
+    return Ipv4Route::equalsWithoutRT(route) && pathSelector == route.pathSelector
+            && outPathId == route.outPathId && fullAddrPath == route.getFullAddrPath() && defaultPathDummy == route.isDefaultPathDummy();
+
+}
+
+bool Ipv4InputPathRoute::equalPaths(const std::vector<Ipv4Address>& cmp) const {
+    return fullAddrPath == cmp;
+}
+
+void Ipv4InputPathRoute::setFullAddrPathFromStack(std::stack<Ipv4Address> _fullAddrPath) {
+    std::vector<Ipv4Address> out;
+    while(!_fullAddrPath.empty()) {
+        out.push_back(_fullAddrPath.top());
+        _fullAddrPath.pop();
+    }
+    if(fullAddrPath != out) {
+        setFullAddrPath(out);
+        setOutPathId(computeOutPathId());
+    }
+}
+
+uint32_t Ipv4InputPathRoute::computeOutPathId() {
+    uint32_t hash = 0;
+    for (int i = 0; i < fullAddrPath.size() - 1; i++) { // remember reverse order!
+        Ipv4Address input = fullAddrPath[fullAddrPath.size() - 1 - i];
+        for (size_t j = 0; j < 4; j++) {
+            hash += input.getDByte(j);
+            hash += hash << 10;
+            hash ^= hash >> 6;
+        }
+    }
+    hash += hash << 3;
+    hash ^= hash >> 11;
+    hash += hash << 15;
+    return hash;
+}
+
+std::string Ipv4InputPathRoute::str() const
+{
+    std::stringstream out;
+    out << getSourceTypeAbbreviation();
+    if (getDestination().isUnspecified())
+        out << " 0.0.0.0";
+    else
+        out << " " << getDestination();
+    out << "/";
+    if (getNetmask().isUnspecified())
+        out << "0";
+    else
+        out << getNetmask().getNetmaskLength();
+    out << " psel:" << unsigned(pathSelector);
+    out << " opid:" << outPathId;
+    //out << " nextIps:" << fullPath;
+    out << " gw:";
+    if (getGateway().isUnspecified())
+        out << "*";
+    else
+        out << getGateway();
+    if(!getFullAddrPath().empty()) {
+        out << " path:";
+        bool first = true;
+        for (auto& elem: getFullAddrPath()) {
+            if (!first)
+                out << ",";
+            out << elem;
+            first = false;
+        }
+    }
+    // cannot access rt table here!
+//        if (rt && rt->isAdminDistEnabled())
+//            out << " AD:" << getAdminDist();
+    out << " metric:" << getMetric();
+    out << " if:";
+    if (!getInterface())
+        out << "*";
+    else
+        out << getInterfaceName();
+
+    if (getProtocolData())
+        out << " " << getProtocolData()->str();
+
+    return out.str();
+}
+} /* namespace inet */
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4InputPathRoute.h inet_od3r/src/inet/networklayer/ipv4/Ipv4InputPathRoute.h
--- inet_orig/src/inet/networklayer/ipv4/Ipv4InputPathRoute.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4InputPathRoute.h	2023-12-20 17:28:39.481935231 +0100
@@ -0,0 +1,87 @@
+//
+//  Author: 2023 Konrad Altenhofen
+//
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#ifndef INET_NETWORKLAYER_IPV4_IPV4INPUTPATHROUTE_H_
+#define INET_NETWORKLAYER_IPV4_IPV4INPUTPATHROUTE_H_
+
+#include "Ipv4Route.h"
+
+#include <stack>
+
+/*
+ * Extra Class for Computed Input Path Id Routes
+ */
+namespace inet {
+
+/**
+ * Ipv4 unicast input path route in IIpv4RoutingTable.
+ *
+ * @see IIpv4RoutingTable, Ipv4RoutingTable
+ * @see Ipv4Route
+ */
+class INET_API Ipv4InputPathRoute: public Ipv4Route {
+private:
+    uint8_t pathSelector = 0; ///< selector used in the disjoint path request
+    uint32_t outPathId = 0; ///< identifier for the residual path excluding the next IP \KAL
+    bool defaultPathDummy = false; ///< indidactor if this is dummy route to prevent unnessary route computation, when current topo routes are too long or non exisistent
+    simtime_t lastPathRefresh = SimTime(0, SIMTIME_MS); ///< time this route was exchanged the last time
+    std::vector<Ipv4Address> fullAddrPath; ///< complete address path including the first (gateway) hop
+
+private:
+    // copying not supported: following are private and also left undefined
+    Ipv4InputPathRoute(const Ipv4InputPathRoute &obj);
+    Ipv4InputPathRoute& operator=(const Ipv4InputPathRoute &obj);
+
+    uint32_t computeOutPathId();
+    virtual void setOutPathId(uint32_t _outPathId) { if (outPathId != _outPathId) { outPathId = _outPathId; changed(F_PATHID); } }; // TODO: update changed parameter
+public:
+    Ipv4InputPathRoute() : Ipv4Route() {setLifetime(SimTime(60,SimTimeUnit::SIMTIME_S)); setSourceType(Ipv4Route::OD3R_CALC); setLastPathRefresh(SIMTIME_ZERO);};
+    virtual ~Ipv4InputPathRoute() { fullAddrPath.clear();};
+
+    virtual std::string str() const override;
+
+    bool operator==(const Ipv4InputPathRoute& route) const { return equals(route); };
+    bool operator!=(const Ipv4InputPathRoute& route) const { return !equals(route); };
+    bool equals(const Ipv4InputPathRoute& route) const;
+    bool equalPaths(const std::vector<Ipv4Address>& cmp) const;
+    bool equalsWithoutRT(const Ipv4InputPathRoute& route) const; // \KAL need to be equal excluding RT to avoid duplicate
+
+    virtual void setPathSelector(uint8_t _pathSelector) { if (pathSelector != _pathSelector) { pathSelector = _pathSelector; setSourceType(Ipv4Route::OD3R_CALC); changed(F_PATHSELECTOR); } }; // TODO: update changed parameter
+    virtual void setFullAddrPath(std::vector<Ipv4Address> _fullAddrPath) { if (fullAddrPath != _fullAddrPath) { fullAddrPath = _fullAddrPath; computeOutPathId(); changed(F_FULLPATH); } }; // TODO: update changed parameter
+
+    virtual void setFullAddrPathFromStack(std::stack<Ipv4Address> _fullAddrPath);
+
+    const uint8_t getPathSelector() const { return pathSelector; };
+    const uint32_t getOutPathId() const { return outPathId; };
+    const std::vector<Ipv4Address> getFullAddrPath() const { return fullAddrPath;};
+
+    void setLastPathRefresh(simtime_t _lastPathRefresh) { if(lastPathRefresh != _lastPathRefresh) lastPathRefresh = _lastPathRefresh;}
+    const simtime_t getTimeSinceLastRefresh() const { return lastPathRefresh == 0 ? SIMTIME_MAX : simTime() - lastPathRefresh; }
+    void setNeedsRefresh() { setLastPathRefresh(SIMTIME_ZERO); };
+    void updateLastPathRefresh() { setLastPathRefresh(simTime()); };
+
+    bool isDefaultPathDummy() const { return defaultPathDummy; }
+    void markAsDefaultPathDummy() { defaultPathDummy = true; changed(F_DEFAULTROUTEMARKER); }
+
+    bool needsRefresh() const { return getTimeSinceLastRefresh() >= (getLifetime() / 2.0);};
+
+};
+
+} /* namespace inet */
+
+#endif /* INET_NETWORKLAYER_IPV4_IPV4INPUTPATHROUTE_H_ */
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4.ned inet_od3r/src/inet/networklayer/ipv4/Ipv4.ned
--- inet_orig/src/inet/networklayer/ipv4/Ipv4.ned	2024-04-17 09:36:27.188726540 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4.ned	2023-12-20 17:28:39.481935231 +0100
@@ -85,6 +85,8 @@
         string routingTableModule;
         string arpModule;
         string icmpModule;
+        bool hasOd3r = default(false); // flag indicating if this node is capable of OD3R \KAL
+        string od3rModule = default(""); // path to the OD3R module \KAL
         string crcMode @enum("declared", "computed") = default("declared");
         int timeToLive = default(32);
         int multicastTimeToLive = default(32);
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4PathIdRoute.cc inet_od3r/src/inet/networklayer/ipv4/Ipv4PathIdRoute.cc
--- inet_orig/src/inet/networklayer/ipv4/Ipv4PathIdRoute.cc	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4PathIdRoute.cc	2023-12-20 17:28:39.481935231 +0100
@@ -0,0 +1,114 @@
+//
+//  Author: 2023 Konrad Altenhofen
+//
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+//
+
+#include "Ipv4PathIdRoute.h"
+
+namespace inet {
+bool Ipv4PathIdRoute::equals(const Ipv4PathIdRoute& route) const
+{
+    return Ipv4Route::equals(route) && pathId == route.pathId && outPathId == route.outPathId;
+}
+
+bool Ipv4PathIdRoute::equalsWithoutRT(const Ipv4PathIdRoute& route) const
+{
+    return Ipv4Route::equalsWithoutRT(route) && pathId == route.pathId && outPathId == route.outPathId;
+
+}
+
+std::string Ipv4PathIdRoute::str() const
+{
+    std::stringstream out;
+    out << getSourceTypeAbbreviation();
+    if (getDestination().isUnspecified())
+        out << " 0.0.0.0";
+    else
+        out << " " << getDestination();
+    out << "/";
+    if (getNetmask().isUnspecified())
+        out << "0";
+    else
+        out << getNetmask().getNetmaskLength();
+    out << " pid:" << pathId;
+    out << " opid:" << outPathId;
+    out << " gw:";
+    if (getGateway().isUnspecified())
+        out << "*";
+    else
+        out << getGateway();
+    // cannot access rt table here!
+//        if (rt && rt->isAdminDistEnabled())
+//            out << " AD:" << getAdminDist();
+    out << " metric:" << getMetric();
+    out << " if:";
+    if (!getInterface())
+        out << "*";
+    else
+        out << getInterfaceName();
+
+    if (getProtocolData())
+        out << " " << getProtocolData()->str();
+
+    return out.str();
+}
+
+void Ipv4PathIdRoute::computeAndSetPathIds(const Ipv4OptionRecordRoute *sourceRouteTLV, size_t startIdx) {
+    uint32_t inHash = jenkinsHash(sourceRouteTLV, startIdx);
+    uint32_t outHash = jenkinsHash(sourceRouteTLV, startIdx + 1);
+
+    ASSERT(outHash == removeLastAddrFromJenkinsHash(inHash, sourceRouteTLV->getRecordAddress(startIdx)));
+
+    setPathId(inHash);
+    setOutPathId(outHash);
+}
+
+uint32_t Ipv4PathIdRoute::jenkinsHash(const Ipv4OptionRecordRoute *sourceRouteTLV, size_t startIdx) const {
+    uint32_t hash = 0;
+    for (size_t i = 0; i < sourceRouteTLV->getRecordAddressArraySize() - startIdx; i++) {
+        Ipv4Address input = sourceRouteTLV->getRecordAddress(sourceRouteTLV->getRecordAddressArraySize() - 1 - i); // use reverse route hash to allow removal of prior
+        for (size_t j = 0; j < 4; j++) {
+            hash += input.getDByte(j);
+            hash += hash << 10;
+            hash ^= hash >> 6;
+        }
+    }
+    hash += hash << 3;
+    hash ^= hash >> 11;
+    hash += hash << 15;
+    return hash;
+}
+
+// Experimental
+// Modified Version from https://stackoverflow.com/questions/53543035/reverse-jenkins-one-at-a-time-hash
+uint32_t Ipv4PathIdRoute::removeLastAddrFromJenkinsHash(uint32_t hash, Ipv4Address lastAddr) const {
+    hash *= 0x3FFF8001;  // inverse of hash += hash << 15;
+    hash ^= (hash >> 11) ^ (hash >> 22);
+    hash *= 0x38E38E39;  // inverse of hash += hash << 3;
+    for (int j = 3; j >= 0; j--) { // use different byte order
+        hash ^= (hash >> 6) ^ (hash >> 12) ^ (hash >> 18) ^ (hash >> 24) ^ (hash >> 30);
+        hash *= 0xC00FFC01;  // inverse of hash += hash << 10;
+        hash -= lastAddr.getDByte(j);
+    }
+    hash += hash << 3;
+    hash ^= hash >> 11;
+    hash += hash << 15;
+    return hash;
+}
+
+
+
+} /* namespace inet */
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4PathIdRoute.h inet_od3r/src/inet/networklayer/ipv4/Ipv4PathIdRoute.h
--- inet_orig/src/inet/networklayer/ipv4/Ipv4PathIdRoute.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4PathIdRoute.h	2023-12-20 17:28:39.481935231 +0100
@@ -0,0 +1,76 @@
+//
+//  Author: 2023 Konrad Altenhofen
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+//
+
+#ifndef INET_NETWORKLAYER_IPV4_IPV4PATHIDROUTE_H_
+#define INET_NETWORKLAYER_IPV4_IPV4PATHIDROUTE_H_
+
+#include "Ipv4Route.h"
+
+
+#include "inet/networklayer/ipv4/Ipv4Header_m.h"
+
+/*
+ * Extra Class for Path Id Routing
+ */
+
+namespace inet {
+
+/**
+ * Ipv4 unicast path id route in IIpv4RoutingTable.
+ *
+ * @see IIpv4RoutingTable, Ipv4RoutingTable
+ * @see Ipv4Route
+ */
+class INET_API Ipv4PathIdRoute: public Ipv4Route
+{
+private:
+    uint32_t pathId = 0; ///< identifier for the residual path \KAL
+    uint32_t outPathId = 0; ///< identifier for the residual path excluding the next IP \KAL
+
+
+private:
+    // copying not supported: following are private and also left undefined
+    Ipv4PathIdRoute(const Ipv4PathIdRoute &obj);
+    Ipv4PathIdRoute& operator=(const Ipv4PathIdRoute &obj);
+
+public:
+    Ipv4PathIdRoute() : Ipv4Route() {setLifetime(SimTime(60,SimTimeUnit::SIMTIME_S)); setSourceType(Ipv4Route::OD3R_SV);};
+    virtual ~Ipv4PathIdRoute() {};
+
+    virtual std::string str() const override;
+
+    bool operator==(const Ipv4PathIdRoute& route) const { return equals(route); }
+    bool operator!=(const Ipv4PathIdRoute& route) const { return !equals(route); }
+    bool equals(const Ipv4PathIdRoute& route) const;
+    bool equalsWithoutRT(const Ipv4PathIdRoute& route) const; // \KAL need to be equal excluding RT to avoid duplicate
+
+    virtual void setPathId(uint32_t _pathId) { if (pathId != _pathId) { pathId = _pathId; sourceTypeName(Ipv4Route::OD3R_SV); changed(F_PATHID); } } // TODO: update changed parameter
+    virtual void setOutPathId(uint32_t _outPathId) { if (outPathId != _outPathId) { outPathId = _outPathId; changed(F_PATHID); } } // TODO: update changed parameter
+
+    virtual void computeAndSetPathIds(const Ipv4OptionRecordRoute *sourceRouteTLV, size_t startIdx); // TODO Update parameters
+
+    virtual uint32_t jenkinsHash(const Ipv4OptionRecordRoute *sourceRouteTLV, size_t startIdx) const;
+    virtual uint32_t removeLastAddrFromJenkinsHash(uint32_t hash, Ipv4Address lastAddr) const;
+
+    const uint32_t getPathId() const { return pathId; }
+    const uint32_t getOutPathId() const { return outPathId; }
+
+};
+
+} /* namespace inet */
+
+#endif /* INET_NETWORKLAYER_IPV4_IPV4PATHIDROUTE_H_ */
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4Route.cc inet_od3r/src/inet/networklayer/ipv4/Ipv4Route.cc
--- inet_orig/src/inet/networklayer/ipv4/Ipv4Route.cc	2024-04-17 09:36:27.188726540 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4Route.cc	2023-12-20 17:28:39.481935231 +0100
@@ -48,6 +48,10 @@
             return "ba";
         case ODR:
             return "o";
+        case OD3R_CALC:
+            return "dc";
+        case OD3R_SV:
+                return "ds";
         default:
             return "???";
     }
@@ -97,6 +101,13 @@
            interfacePtr == route.interfacePtr && sourceType == route.sourceType && metric == route.metric;
 }
 
+bool Ipv4Route::equalsWithoutRT(const Ipv4Route& route) const
+{
+    return dest == route.dest && netmask == route.netmask && gateway == route.gateway &&
+           interfacePtr == route.interfacePtr && sourceType == route.sourceType && metric == route.metric;
+
+}
+
 const char *Ipv4Route::getInterfaceName() const
 {
     return interfacePtr ? interfacePtr->getInterfaceName() : "";
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4Route.h inet_od3r/src/inet/networklayer/ipv4/Ipv4Route.h
--- inet_orig/src/inet/networklayer/ipv4/Ipv4Route.h	2024-04-17 09:36:27.188726540 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4Route.h	2023-12-20 17:28:39.481935231 +0100
@@ -34,6 +34,12 @@
     int metric; ///< Metric ("cost" to reach the destination)
     cObject *source; ///< Object identifying the source
     cObject *protocolData; ///< Routing Protocol specific data
+    // \KAL
+    simtime_t expiryTime = SimTime(0, SIMTIME_MS);
+    simtime_t lifetime = SimTime(0, SIMTIME_MS);
+  protected:
+    bool valid = true; // \KAL
+
 
   private:
     // copying not supported: following are private and also left undefined
@@ -53,13 +59,15 @@
     bool operator==(const Ipv4Route& route) const { return equals(route); }
     bool operator!=(const Ipv4Route& route) const { return !equals(route); }
     bool equals(const Ipv4Route& route) const;
+    bool equalsWithoutRT(const Ipv4Route& route) const; // \KAL need to be equal excluding RT to avoid duplicate
 
     /** To be called by the routing table when this route is added or removed from it */
     virtual void setRoutingTable(IIpv4RoutingTable *rt) { this->rt = rt; }
     IIpv4RoutingTable *getRoutingTable() const { return rt; }
 
     /** test validity of route entry, e.g. check expiry */
-    virtual bool isValid() const { return true; }
+    virtual bool isValid() const { return valid; }
+    virtual void setInvalid() { valid = false; }
 
     virtual void setDestination(Ipv4Address _dest) { if (dest != _dest) { dest = _dest; changed(F_DESTINATION); } }
     virtual void setNetmask(Ipv4Address _netmask) { if (netmask != _netmask) { netmask = _netmask; changed(F_PREFIX_LENGTH); } }
@@ -69,6 +77,20 @@
     const char *getSourceTypeAbbreviation() const;
     virtual void setAdminDist(unsigned int _adminDist) override { if (adminDist != _adminDist) { adminDist = _adminDist; changed(F_ADMINDIST); } }
     virtual void setMetric(int _metric) override { if (metric != _metric) { metric = _metric; changed(F_METRIC); } }
+    // \KAL additional expiry time stuff
+    virtual void setExpireTime(simtime_t _expiryTime) { if(expiryTime != _expiryTime) { expiryTime = _expiryTime; changed(F_EXPIRYTIME); }};
+    virtual void refreshExpiryTime(simtime_t _deltaToAdd) {setExpireTime(simTime() + _deltaToAdd);};
+    virtual void refreshExpiryTime() {setExpireTime(simTime() + lifetime);};
+    virtual void setLifetime(simtime_t _lifetime) {lifetime=_lifetime; refreshExpiryTime();};
+    virtual bool isExpireable() { return !(expiryTime==0);};
+
+    const simtime_t getExpiryTime() const { return expiryTime; };
+    const simtime_t getLifetime() const { return lifetime; };
+    const simtime_t getRemainingLifetime() const { return expiryTime == 0 ? SIMTIME_MAX : expiryTime - simTime();}
+
+    // \KAL flags for routeType
+    const bool isPathIdRoute() const { return sourceType == OD3R_SV; }
+    const bool isInputPathRoute() const { return sourceType == OD3R_CALC; }
 
     /** Destination address prefix to match */
     const Ipv4Address& getDestination() const { return dest; }
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4RoutingTable.cc inet_od3r/src/inet/networklayer/ipv4/Ipv4RoutingTable.cc
--- inet_orig/src/inet/networklayer/ipv4/Ipv4RoutingTable.cc	2024-04-17 09:36:27.188726540 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4RoutingTable.cc	2023-12-20 17:28:39.481935231 +0100
@@ -24,6 +24,11 @@
 #include "inet/networklayer/ipv4/Ipv4Route.h"
 #include "inet/networklayer/ipv4/RoutingTableParser.h"
 
+// \KAL
+#include <inet/networklayer/ipv4/Ipv4PathIdRoute.h>
+#include <inet/networklayer/ipv4/Ipv4InputPathRoute.h>
+
+
 namespace inet {
 
 using namespace utils;
@@ -200,11 +205,18 @@
     for (auto it = routes.begin(); it != routes.end();) {
         Ipv4Route *route = *it;
         if (route->getInterface() == entry) {
-            it = routes.erase(it);
-            invalidateCache();
-            ASSERT(route->getRoutingTable() == this); // still filled in, for the listeners' benefit
-            emit(routeDeletedSignal, route);
-            delete route;
+            if(route->getSourceType() == Ipv4Route::OD3R_CALC
+                    || route->getSourceType() == Ipv4Route::OD3R_SV) { // soft remove
+                route->setInvalid(); // make sure this is not used but do not remove (let adder handle this)
+                ++it;
+            }
+            else {
+                it = routes.erase(it);
+                invalidateCache();
+                ASSERT(route->getRoutingTable() == this); // still filled in, for the listeners' benefit
+                emit(routeDeletedSignal, route);
+                delete route;
+            }
         }
         else
             ++it;
@@ -235,6 +247,7 @@
 void Ipv4RoutingTable::invalidateCache()
 {
     routingCache.clear();
+    //multipathRoutingCache.clear(); // \KAL check if pairs need to be deleted as well
     localBroadcastAddresses.clear();
 }
 
@@ -402,7 +415,7 @@
     // default route has zero prefix length, so (if exists) it'll be selected as last resort
     Ipv4Route *bestRoute = nullptr;
     for (auto e : routes) {
-        if (e->isValid()) {
+        if (e->isValid() && !e->isPathIdRoute() && !e->isInputPathRoute()) { // \KAL ensure only default routes are selected
             if (Ipv4Address::maskedAddrAreEqual(dest, e->getDestination(), e->getNetmask())) { // match
                 bestRoute = const_cast<Ipv4Route *>(e);
                 break;
@@ -414,6 +427,78 @@
     return bestRoute;
 }
 
+// \KAL extra method which checks first for preferably valid Path Id Route. If only a invalid route is present, this route is returned. If no Path Id Route is present, return the best matching route
+Ipv4Route *Ipv4RoutingTable::findBestMatchingRoute(const Ipv4Address& dest, const uint32_t pathId) const
+{
+    Enter_Method("findBestMatchingRoute(%u.%u.%u.%u, %u)", dest.getDByte(0), dest.getDByte(1), dest.getDByte(2), dest.getDByte(3), pathId); // note: str().c_str() too slow here
+
+    // TODO: use/update Routing cache
+    /*
+    auto it = multipathRoutingCache.find(std::make_pair(dest, pathId));
+    if (it != multipathRoutingCache.end()) {
+        if (it->second == nullptr || it->second->isValid())
+            return it->second;
+    }
+    */
+
+    // find best match (one with longest prefix)
+    // default route has zero prefix length, so (if exists) it'll be selected as last resort
+    Ipv4Route *bestRoute = nullptr;
+    for (auto e : routes) {
+       if (e->isValid() && e->isPathIdRoute()) {
+            Ipv4PathIdRoute *pidEle = check_and_cast_nullable<Ipv4PathIdRoute *>(e);
+            if (Ipv4Address::maskedAddrAreEqual(dest, e->getDestination(), e->getNetmask()) &&
+                    pathId == pidEle->getPathId()) { // match
+                bestRoute = const_cast<Ipv4Route *>(e);
+                break;
+            }
+        }
+    }
+    if (bestRoute) {
+        //multipathRoutingCache[std::make_pair(dest, pathId)] = bestRoute;
+        return bestRoute;
+    }
+    else
+        //return findBestMatchingRoute(dest);
+        return nullptr;
+}
+
+// \KAL extra method which checks first for preferably valid Input Route. If only a invalid route is present, this route is returned. If no Input Route is present, return nullptr
+Ipv4Route *Ipv4RoutingTable::findBestMatchingInRoute(const Ipv4Address& dest, const uint8_t pathSelector) const
+{
+    Enter_Method("findBestMatchingInRoute(%u.%u.%u.%u, %u)", dest.getDByte(0), dest.getDByte(1), dest.getDByte(2), dest.getDByte(3), pathSelector); // note: str().c_str() too slow here
+
+    // TODO: use/update Routing cache
+    /*
+    auto it = multipathRoutingCache.find(std::make_pair(dest, pathId));
+    if (it != multipathRoutingCache.end()) {
+        if (it->second == nullptr || it->second->isValid())
+            return it->second;
+    }
+    */
+
+    // find best match (one with longest prefix)
+    // default route has zero prefix length, so (if exists) it'll be selected as last resort
+    Ipv4Route *bestRoute = nullptr;
+    for (auto e : routes) {
+        if (e->isInputPathRoute()) { // since soft delete e->isValid() could be false, however then we would not need to recalculate
+            Ipv4InputPathRoute *pidEle = check_and_cast_nullable<Ipv4InputPathRoute *>(e);
+            if (Ipv4Address::maskedAddrAreEqual(dest, e->getDestination(), e->getNetmask())
+                    && pathSelector == pidEle->getPathSelector()) { // match
+                if(e->isValid() || !bestRoute) bestRoute = const_cast<Ipv4Route *>(e);
+                if(e->isValid()) break;
+            }
+        }
+    }
+    if (bestRoute) {
+        //multipathRoutingCache[std::make_pair(dest, pathId)] = bestRoute;
+        return bestRoute;
+    }
+    else
+        //return findBestMatchingRoute(dest);
+        return nullptr;
+}
+
 NetworkInterface *Ipv4RoutingTable::getInterfaceForDestAddr(const Ipv4Address& dest) const
 {
     Enter_Method("getInterfaceForDestAddr(%u.%u.%u.%u)", dest.getDByte(0), dest.getDByte(1), dest.getDByte(2), dest.getDByte(3)); // note: str().c_str() too slow here
@@ -457,7 +542,7 @@
 {
     // if exists default route entry, it is the last valid entry
     for (RouteVector::const_reverse_iterator i = routes.rbegin(); i != routes.rend() && (*i)->getNetmask().isUnspecified(); ++i) {
-        if ((*i)->isValid())
+        if ((*i)->isValid() && !(*i)->isPathIdRoute() && !(*i)->isInputPathRoute()) // \KAL the default route shouldn't be a MP route
             return *i;
     }
     return nullptr;
@@ -508,7 +593,8 @@
         throw cRuntimeError("addRoute(): interface cannot be nullptr");
 
     // if this is a default route, remove old default route (we're replacing it)
-    if (entry->getNetmask().isUnspecified()) {
+    if (entry->getNetmask().isUnspecified() && !entry->isPathIdRoute() && !entry->isInputPathRoute()) { // \KAL: ensure that the route is only set
+        // to the default, if its not a MP route
         Ipv4Route *oldDefaultRoute = getDefaultRoute();
         if (oldDefaultRoute != nullptr)
             deleteRoute(oldDefaultRoute);
@@ -529,6 +615,34 @@
     entry->setRoutingTable(this);
 }
 
+// \KAL
+Ipv4Route *Ipv4RoutingTable::addRouteIfNew(Ipv4Route *entry) {
+    Enter_Method("addRouteIfNew(...)");
+
+    for (auto i = routes.begin(); i != routes.end(); ++i) {
+        if ((*i)->equalsWithoutRT(*entry)) {
+            // Ugly work around, since we can't access check_and_cast within equals
+            if (entry->isInputPathRoute()) {
+                Ipv4InputPathRoute * inPathRoute = check_and_cast_nullable<Ipv4InputPathRoute *>(entry);
+                const Ipv4InputPathRoute * cmp = check_and_cast_nullable<const Ipv4InputPathRoute *>((*i));
+                if (!cmp || !inPathRoute->equalsWithoutRT(*cmp)) {
+                    continue;
+                }
+            }
+            if (entry->isPathIdRoute()) {
+                Ipv4PathIdRoute * inPathRoute = check_and_cast_nullable<Ipv4PathIdRoute *>(entry);
+                const Ipv4PathIdRoute * cmp = check_and_cast_nullable<const Ipv4PathIdRoute *>((*i));
+                if (!cmp || !inPathRoute->equalsWithoutRT(*cmp)) {
+                    continue;
+                }
+            }
+            return (*i);
+        }
+    }
+   addRoute(entry);
+   return entry;
+}
+
 void Ipv4RoutingTable::addRoute(Ipv4Route *entry)
 {
     Enter_Method("addRoute(...)");
@@ -679,8 +793,10 @@
 }
 
 void Ipv4RoutingTable::routeChanged(Ipv4Route *entry, int fieldCode)
-{
-    if (fieldCode == Ipv4Route::F_DESTINATION || fieldCode == Ipv4Route::F_PREFIX_LENGTH || fieldCode == Ipv4Route::F_METRIC) { // our data structures depend on these fields
+{ // \KAL add change method for PathId
+    if (fieldCode == Ipv4Route::F_DESTINATION || fieldCode == Ipv4Route::F_PREFIX_LENGTH || fieldCode == Ipv4Route::F_METRIC ||
+            fieldCode == Ipv4Route::F_PATHID || fieldCode == Ipv4Route::F_PATHSELECTOR || fieldCode == Ipv4Route::F_FULLPATH ||
+            fieldCode == Ipv4Route::F_DEFAULTROUTEMARKER) { // our data structures depend on these fields
         entry = internalRemoveRoute(entry);
         ASSERT(entry != nullptr); // failure means inconsistency: route was not found in this routing table
         internalAddRoute(entry);
diff -Naur inet_orig/src/inet/networklayer/ipv4/Ipv4RoutingTable.h inet_od3r/src/inet/networklayer/ipv4/Ipv4RoutingTable.h
--- inet_orig/src/inet/networklayer/ipv4/Ipv4RoutingTable.h	2024-04-17 09:36:27.188726540 +0200
+++ inet_od3r/src/inet/networklayer/ipv4/Ipv4RoutingTable.h	2023-12-20 17:28:39.481935231 +0100
@@ -80,6 +80,10 @@
     typedef std::map<Ipv4Address, Ipv4Route *> RoutingCache;
     mutable RoutingCache routingCache;
 
+    // \KAL Multipath routing Cache
+    typedef std::map<std::pair<Ipv4Address, uint32_t>, Ipv4Route *> MultipathRoutingCache;
+    mutable MultipathRoutingCache multipathRoutingCache;
+
     // local addresses cache (to speed up isLocalAddress())
     typedef std::set<Ipv4Address> AddressSet;
     // JcM add: to handle the local broadcast address
@@ -290,6 +294,12 @@
     virtual void addRoute(Ipv4Route *entry) override;
 
     /**
+     * \KAL add Route if new
+     * Adds the route to the routing table, if it is not already present in the routing table
+     */
+    virtual Ipv4Route *addRouteIfNew(Ipv4Route *entry) override;
+
+    /**
      * Removes the given route from the routing table, and returns it.
      * nullptr is returned of the route was not in the routing table.
      */
@@ -372,9 +382,20 @@
     virtual bool isLocalMulticastAddress(const L3Address& dest) const override { return isLocalMulticastAddress(dest.toIpv4()); }
     virtual IMulticastRoute *findBestMatchingMulticastRoute(const L3Address& origin, const L3Address& group) const override { return const_cast<Ipv4MulticastRoute *>(findBestMatchingMulticastRoute(origin.toIpv4(), group.toIpv4())); } // TODO remove 'const' from Ipv4 method?
     virtual IRoute *createRoute() override { return new Ipv4Route(); }
+    // \KAL
+    /**
+     * extra method which checks first for preferably valid Path Id Route. If only an invalid route is present, this route is returned. If no Path Id Route is present, return the best matching route
+     */
+    virtual Ipv4Route *findBestMatchingRoute(const Ipv4Address& dest, const uint32_t pathId) const override;
+    /**
+     * extra method which checks first for preferably valid Input Route. If only an invalid route is present, this route is returned. If no Input Route is present, return nullptr
+     */
+    virtual Ipv4Route *findBestMatchingInRoute(const Ipv4Address& dest, const uint8_t pathSelector) const override;
+
 
   private:
     virtual void addRoute(IRoute *entry) override { addRoute(check_and_cast<Ipv4Route *>(entry)); }
+
     virtual IRoute *removeRoute(IRoute *entry) override { return removeRoute(check_and_cast<Ipv4Route *>(entry)); }
     virtual bool deleteRoute(IRoute *entry) override { return deleteRoute(check_and_cast<Ipv4Route *>(entry)); }
 
diff -Naur inet_orig/src/inet/networklayer/od3r/IOd3rPathComputationElement.h inet_od3r/src/inet/networklayer/od3r/IOd3rPathComputationElement.h
--- inet_orig/src/inet/networklayer/od3r/IOd3rPathComputationElement.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/IOd3rPathComputationElement.h	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,45 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#ifndef INET_NETWORKLAYER_OD3R_IOD3RPATHCOMPUTATIONELEMENT_H_
+#define INET_NETWORKLAYER_OD3R_IOD3RPATHCOMPUTATIONELEMENT_H_
+
+#include <stack>
+
+#include "inet/common/INETDefs.h"
+
+#include "inet/networklayer/contract/ipv4/Ipv4Address.h"
+
+namespace inet {
+
+/**
+ * Helper class mainly used for the typedefs
+ */
+class INET_API IOd3rPathComputationElement {
+protected:
+    typedef std::stack<Ipv4Address> Ipv4PathStack;
+    typedef std::pair<Ipv4PathStack, Ipv4PathStack> Ipv4PathPair;
+    typedef std::pair<Ipv4Address, double> Ipv4DestCost;
+    typedef std::pair<Ipv4PathStack, double> Ipv4PathCost;
+public:
+    virtual ~IOd3rPathComputationElement() {}
+    virtual Ipv4PathPair computeSuurballe(const Ipv4Address &destAddr) = 0;
+};
+
+} /* namespace inet */
+
+#endif /* INET_NETWORKLAYER_OD3R_IOD3RPATHCOMPUTATIONELEMENT_H_ */
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3r.cc inet_od3r/src/inet/networklayer/od3r/Od3r.cc
--- inet_orig/src/inet/networklayer/od3r/Od3r.cc	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3r.cc	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,396 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#include "inet/networklayer/od3r/Od3r.h"
+
+
+#include "inet/networklayer/contract/IInterfaceTable.h"
+#include "inet/networklayer/ipv4/IIpv4RoutingTable.h"
+
+
+#include <inet/networklayer/ipv4/Ipv4PathIdRoute.h>
+#include "inet/networklayer/ipv4/Ipv4InputPathRoute.h"
+#include "inet/networklayer/ipv4/Ipv4InterfaceData.h"
+
+#include <queue>
+
+namespace inet {
+
+Define_Module(Od3r);
+
+Od3r::Od3r() {
+}
+
+Od3r::~Od3r() {
+    stop();
+}
+
+void Od3r::initialize(int stage)
+{
+    RoutingProtocolBase::initialize(stage);
+
+    if (stage == INITSTAGE_LOCAL) {
+        setupStatistics();
+
+        rt.reference(this, "routingTableModule", true);
+        ift.reference(this, "interfaceTableModule", true);
+        pce.reference(this, "pceModule", true);
+
+        computedRouteLifetime = par("computedRouteLifetime");
+        exchangedRouteLifetime = par("exchangedRouteLifetime");
+        createDefaultRoutingTable = par("createDefaultRoutingTable");
+        dumpRoutingTableAfterChange = par("dumpRoutingTableAfterChange");
+    }
+    else if (stage == INITSTAGE_LAST) {
+        cModule *host = getContainingNode(this);
+        host->subscribe(Od3rGlobalRoutingPCE::od3rTopologyChanged, this);
+    }
+}
+
+void Od3r::initializeOD3R()
+{
+    routerId = rt->getRouterId();
+    if(!pce->isTopologySet()) pce->setCurrentTopology();
+    if(createDefaultRoutingTable) TIME(createDefaultRoutingTableEntries());
+    if(createDefaultRoutingTable) rt->printRoutingTable();
+    ASSERT(!routerId.isUnspecified());
+}
+void Od3r::stop() {
+    getSimulation()->getSystemModule()->unsubscribe(POST_MODEL_CHANGE, this);
+    for (auto& elem : scheduledRoutes) {
+        cancelAndDelete(elem.second);
+    }
+    scheduledRoutes.clear();
+    noticeNodeStop();
+    resetStatistics();
+}
+
+void Od3r::resetStatistics()
+{
+    numCurrRoutes = 0;
+}
+void Od3r::setupStatistics() {
+    numComputations = 0;
+    resetStatistics();
+
+    WATCH(numComputations);
+    WATCH(numRTRefreshments);
+
+    WATCH(numSourceRouteExchangePackets);
+    WATCH(numResidualPathPackets);
+    WATCH(numResidualPathRequests);
+
+    WATCH(numMissingPIdRoutes);
+    WATCH(numMissingDefaultEntries);
+    WATCH(numDefaultPathDummyUse);
+
+    WATCH(numAddedRoutes);
+    WATCH(numDecayedRoutes);
+    WATCH(numCurrRoutes);
+}
+
+void Od3r::finish()
+{
+    recordScalar("number disjoint path computations", numComputations);
+    recordScalar("number routing table refreshments", numRTRefreshments);
+
+    recordScalar("number added routes", numAddedRoutes);
+    recordScalar("number decayed routes", numDecayedRoutes);
+
+    recordScalar("number PID RT misses", numMissingPIdRoutes);
+    recordScalar("number missing default entries", numMissingDefaultEntries);
+    recordScalar("number used default route dummys", numDefaultPathDummyUse);
+    recordScalar("number missing input paths route due to soft delete", numPathInSoftDelete);
+
+    recordScalar("number source route packets", numSourceRouteExchangePackets);
+    recordScalar("number residual path routed packets", numResidualPathPackets);
+    recordScalar("number residual path request packets", numResidualPathRequests);
+
+    RoutingProtocolBase::finish();
+}
+
+void Od3r::receiveSignal(cComponent *source, simsignal_t signalID, long l, cObject *details)
+{
+    Enter_Method("%s", cComponent::getSignalName(signalID));
+    printSignalBanner(signalID, l, details);
+
+    if (pce->isTopologySet()) {
+        EV_INFO << "Topology changed changed, update RT \n";
+        if(createDefaultRoutingTable) TIME(createDefaultRoutingTableEntries());
+        TIME(rebuildInputRoutesInRT());
+    }
+
+}
+
+void Od3r::handleMessageWhenUp(cMessage *msg)
+{
+    if (msg->isSelfMessage()) {
+        // scheduled deletion
+        deleteExpiredRoutes(msg);
+    }
+    else
+        throw cRuntimeError("Message not allowed");
+}
+void Od3r::handleStartOperation(LifecycleOperation *operation)
+{
+    initializeOD3R();
+}
+void Od3r::handleStopOperation(LifecycleOperation *operation)
+{
+    stop();
+}
+void Od3r::handleCrashOperation(LifecycleOperation *operation)
+{
+    stop();
+}
+
+Od3r::Ipv4PathPair Od3r::computeDisjointPaths(const Ipv4Address &destAddr) {
+    Enter_Method("computeDisjointPaths(%u.%u.%u.%u)", destAddr.getDByte(0), destAddr.getDByte(1), destAddr.getDByte(2), destAddr.getDByte(3));
+    noticeComputation();
+    return pce->computeSuurballe(destAddr, routerId);
+}
+
+void Od3r::deleteExpiredRoutes(cMessage *msg) {
+    Enter_Method("deleteExpiredRoutes(...)");
+    for(std::map<Ipv4Route*, cMessage*>::iterator iter = scheduledRoutes.begin(); iter != scheduledRoutes.end(); ++iter){
+        if(iter->second == msg) {
+            EV_INFO << "Delete unused route entry " << iter->first->str() << endl;
+            rt->removeRoute(iter->first);
+            scheduledRoutes.erase(iter->first);
+            noticeDecayRoute();
+            break;
+        }
+    }
+    delete msg;
+}
+bool Od3r::checkDisjointPathPairIfUseable(Ipv4PathPair pairToCheck) {
+    return pce->checkDisjointPathPairIfUseable(pairToCheck);
+}
+
+void Od3r::refreshRouteEntry(Ipv4Route* re) {
+    Enter_Method("refreshRouteEntry(...)");
+    if (!re->isExpireable())
+        return;
+    re->refreshExpiryTime();
+    // check if route is already scheduled
+    if(scheduledRoutes.find(re) != scheduledRoutes.end()) { // is scheduled -> reschedule event
+        noticeRTRefreshment();
+        EV_INFO << "refresh route entry " << re->str() << endl;
+        rescheduleAt(re->getExpiryTime(), scheduledRoutes[re]);
+    }
+    else { // not scheduled atm -> add to map and create schedule event
+        noticeAddedRoute();
+        EV_INFO << "add expire-able route entry " << re->str() << endl;
+        scheduledRoutes[re] = new cMessage("Od3r::RouteExpire");
+        scheduleAt(re->getExpiryTime(), scheduledRoutes[re]);
+    }
+}
+
+void Od3r::addRouteEntry(Ipv4Route* re) {
+    Ipv4Route * entry = rt->addRouteIfNew(re);
+    // create deletion timer
+    refreshRouteEntry(entry);
+}
+
+void Od3r::rebuildInputRoutesInRT() {
+    Enter_Method("rebuildInputRoutesInRT()");
+    EV_INFO << "Rebuilding OD3R routes of RT in router[" << routerId << "]" << endl;
+    std::map<Ipv4Address, simtime_t> destinations;
+    for(int i=0;i<rt->getNumRoutes();) {
+        // go though all routes in rt
+        auto* route = rt->getRoute(i);
+        if (route->getSourceType() == Ipv4Route::OD3R_CALC) { // check if this is added by OD3R
+            auto destAddr = route->getDestination();
+            auto expiryTime = route->getExpiryTime();
+            if(!(destinations.find(destAddr) != destinations.end()) or destinations[destAddr] < expiryTime) { // destination not in destinations list or expiryTime is lower
+                destinations[destAddr] = expiryTime;
+            }
+
+             // ...
+            EV_INFO << "remove input route entry " << route->str() << endl;
+            auto *msg = scheduledRoutes[route]; // remove decay timer ...
+            scheduledRoutes.erase(route);
+            cancelAndDelete(msg);
+            --numCurrRoutes;
+            rt->removeRoute(route); // ... and delete these route
+
+        }
+        else if (route->getSourceType() == Ipv4Route::OD3R_SV && !route->isValid()) {
+            EV_INFO << "remove path id route entry " << route->str() << endl;
+            auto *msg = scheduledRoutes[route]; // remove decay timer ...
+            scheduledRoutes.erase(route);
+            cancelAndDelete(msg);
+            --numCurrRoutes;
+            rt->removeRoute(route); // ... and delete these route
+        }
+        else
+            ++i;
+    }
+    for(std::map<Ipv4Address, simtime_t>::iterator  iter = destinations.begin(); iter != destinations.end(); ++iter) {
+        auto paths = computeDisjointPaths(iter->first); // recompute
+        numAddedRoutes -= 2; // fix counter
+        addInputRouteEntrys(iter->first, paths, 255, iter->second); // ... and add then again
+    }
+}
+
+void Od3r::addInputRouteEntrys(const Ipv4Address &destAddr,
+        Od3r::Ipv4PathPair paths, uint8_t selectedPath, simtime_t routeExpiryTime) {
+    Ipv4Address netmask = getNetmaskForDestByHighestPrefix(destAddr);
+
+    ASSERT2(netmask != Ipv4Address::UNSPECIFIED_ADDRESS, "No netmask for destination address found.");
+
+    bool useableDisjointPathPair = checkDisjointPathPairIfUseable(paths);
+
+    Ipv4InputPathRoute *newInReFirst = new Ipv4InputPathRoute();
+
+    newInReFirst->setPathSelector(0);
+    newInReFirst->setFullAddrPathFromStack(paths.first);
+    if (paths.first.size() == 0)
+        newInReFirst->setGateway(Ipv4Address::LOOPBACK_ADDRESS);
+    else
+        newInReFirst->setGateway(newInReFirst->getFullAddrPath().at(0));
+    newInReFirst->setDestination(destAddr.doAnd(netmask));
+    newInReFirst->setNetmask(netmask);
+    newInReFirst->setLifetime(computedRouteLifetime);
+    if (!routeExpiryTime.isZero()) newInReFirst->setExpireTime(routeExpiryTime);
+    auto *nextHopInterface1 = getInterfaceForNeighborAddress(newInReFirst->getGateway());
+    if (nextHopInterface1)
+        newInReFirst->setInterface(nextHopInterface1);
+    else
+        EV_INFO << "No gateway interface for input path with selector 0 for gateway: " << newInReFirst->getGateway().str() << endl;
+    if (selectedPath == 0) newInReFirst->updateLastPathRefresh(); // make sure only the used path is marked as refreshed
+    if (!useableDisjointPathPair) newInReFirst->markAsDefaultPathDummy();
+    addRouteEntry(newInReFirst);
+
+    Ipv4InputPathRoute *newInReSecond = new Ipv4InputPathRoute();
+
+    newInReSecond->setPathSelector(1);
+    newInReSecond->setFullAddrPathFromStack(paths.second);
+    if (paths.second.size() == 0)
+        newInReSecond->setGateway(Ipv4Address::LOOPBACK_ADDRESS);
+    else
+        newInReSecond->setGateway(newInReSecond->getFullAddrPath().at(0));
+    newInReSecond->setDestination(destAddr.doAnd(netmask));
+    newInReSecond->setNetmask(netmask);
+    newInReSecond->setLifetime(computedRouteLifetime);
+    if (!routeExpiryTime.isZero()) newInReSecond->setExpireTime(routeExpiryTime);
+    auto *nextHopInterface2 = getInterfaceForNeighborAddress(newInReSecond->getGateway());
+    if (nextHopInterface2)
+        newInReSecond->setInterface(nextHopInterface2);
+    else
+        EV_INFO << "No gateway interface for input path with selector 1 for gateway: " << newInReSecond->getGateway().str() << endl;
+    if (selectedPath == 1) newInReSecond->updateLastPathRefresh(); // make sure only the used path is marked as refreshed
+    if (!useableDisjointPathPair) newInReSecond->markAsDefaultPathDummy();
+    addRouteEntry(newInReSecond);
+}
+
+void Od3r::addPathIdRouteEntry(const NetworkInterface& destIE, const Ipv4Address &destAddr,
+            const Ipv4OptionRecordRoute& sourceRouteTLV, const Ipv4Address& sourceNextHopAddr) {
+    Ipv4Address netmask = getNetmaskForDestByHighestPrefix(destAddr);
+    ASSERT2(netmask != Ipv4Address::UNSPECIFIED_ADDRESS, "No netmask for destination address found.");
+
+    short nextAddrIdx = sourceRouteTLV.getNextAddressIdx();
+    short remainingAddrIdx =  ((sourceRouteTLV.getLength() - 3) >> 2) - nextAddrIdx;
+
+    Ipv4PathIdRoute *newRe = new Ipv4PathIdRoute();
+    newRe->setGateway(sourceNextHopAddr);
+    newRe->setInterface(ift->getInterfaceById(destIE.getInterfaceId()));
+
+    ASSERT(sourceRouteTLV.getRecordAddressArraySize() == sourceRouteTLV.getNextAddressIdx() + remainingAddrIdx);
+    newRe->computeAndSetPathIds(&sourceRouteTLV, sourceRouteTLV.getNextAddressIdx());
+
+    newRe->setDestination(destAddr.doAnd(netmask));
+    newRe->setNetmask(netmask);
+    newRe->setLifetime(exchangedRouteLifetime);
+
+    addRouteEntry(newRe);
+}
+
+NetworkInterface *Od3r::getInterfaceForNeighborAddress(const Ipv4Address& neighborAddr) {
+    for (int i=0; i<ift->getNumInterfaces();++i) {
+        NetworkInterface *ie = ift->getInterface(i);
+        if (ie) {
+            if (auto ipv4Data = ie->findProtocolData<Ipv4InterfaceData>()) {
+                Ipv4Address ipv4Addr = ipv4Data->getIPAddress();
+                Ipv4Address netmask = ipv4Data->getNetmask();
+                if (Ipv4Address::maskedAddrAreEqual(neighborAddr, ipv4Addr, netmask))
+                    return ie;
+            }
+        }
+    }
+    throw cRuntimeError("Address is not a interface neighbor");
+    return nullptr;
+}
+Ipv4Address Od3r::getNetmaskForDestByHighestPrefix(const Ipv4Address &destAddr) const {
+    return pce->getNetmaskForDestByHighestPrefix(destAddr);
+}
+
+void Od3r::createDefaultRoutingTableEntries() {
+    Enter_Method("createDefaultRoutingTableEntries()");
+    EV_INFO << "Rebuilding default routes of RT in router[" << routerId << "]" << endl;
+    // delete old default routes
+    for(int i=0;i<rt->getNumRoutes();) {
+        // go though all routes in rt
+        auto* route = rt->getRoute(i);
+        if (route->getSourceType() == Ipv4Route::MANUAL) { // check if this is default route
+            rt->removeRoute(route);
+        }
+        else {
+            ++i;
+        }
+    }
+
+
+    auto routeMap = pce->createDefaultRoutingMap(routerId); // create route map
+    for(auto& element: routeMap) { //
+        auto& gateway = element.first;
+        if (gateway.isUnspecified()) { // direct connection(s)
+            for (std::set<std::pair<uint32_t, Ipv4Address>>::iterator itr = element.second.begin(); itr != element.second.end(); itr++) {
+                Ipv4Route *route = new Ipv4Route();
+                Ipv4Address netmask = Ipv4Address::makeNetmask(32 - (*itr).first);
+                Ipv4Address connectingAddr = (*itr).second;
+                auto interface = getInterfaceForNeighborAddress(connectingAddr);
+                route->setDestination((*itr).second);
+                route->setNetmask(netmask);
+                route->setGateway(gateway);
+                route->setInterface(interface);
+                route->setSourceType(Ipv4Route::MANUAL);
+                rt->addRoute(route);
+            }
+        }
+        else { // gateway connection(s)
+            auto interface = getInterfaceForNeighborAddress(gateway);
+            for (std::set<std::pair<uint32_t, Ipv4Address>>::iterator itr = element.second.begin(); itr != element.second.end(); itr++) {
+                Ipv4Route *route = new Ipv4Route();
+                route->setDestination((*itr).second);
+                route->setNetmask(Ipv4Address::makeNetmask(32 - (*itr).first));
+                route->setGateway(gateway);
+                route->setInterface(interface);
+                route->setSourceType(Ipv4Route::MANUAL);
+                rt->addRoute(route);
+            }
+        }
+    }
+
+    // clean up
+    for (auto& element: routeMap) {
+        element.second.clear();
+    }
+    routeMap.clear();
+
+}
+} /* namespace inet */
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.cc inet_od3r/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.cc
--- inet_orig/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.cc	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.cc	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,606 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#include "Od3rGlobalRoutingPCE.h"
+
+#include "inet/networklayer/contract/IInterfaceTable.h"
+#include "inet/networklayer/ipv4/IIpv4RoutingTable.h"
+
+#include <queue>
+
+namespace inet {
+
+Define_Module(Od3rGlobalRoutingPCE);
+
+simsignal_t Od3rGlobalRoutingPCE::od3rTopologyChanged = registerSignal("od3rTopologyChanged");
+
+Od3rGlobalRoutingPCE::~Od3rGlobalRoutingPCE() {
+    stop();
+}
+
+void Od3rGlobalRoutingPCE::initialize(int stage)
+{
+    RoutingProtocolBase::initialize(stage);
+
+    if (stage == INITSTAGE_LOCAL) {
+        rt.reference(this, "routingTableModule", true);
+        ift.reference(this, "interfaceTableModule", true);
+        od3r.reference(this, "od3rModule", true);
+
+        changePropagationDelayPar = &par("changePropagationTime");
+        changeMergeJitter = par("changeMergeJitter");
+        computeDefaultPaths = par("computeDefaultPaths");
+        addDefaultRoutes = par("addDefaultRoutes");
+        addDirectRoutes = par("addDirectRoutes");
+        addSubnetRoutes = par("addSubnetRoutes");
+        optimizeRoutes = par("optimizeRoutes");
+        fastLocalPropagation = par("fastLocalPropagation");
+
+        topologySet = false;
+        shortestPathsCalculated = false;
+
+        WATCH(numSuurballeComputations);
+        WATCH(numDjikstraComputations);
+        WATCH(numTopologyChangesPre);
+        WATCH(numTopologyChangesPost);
+        WATCH(numDefaultRouteMapsCreated);
+    }
+    else if (stage == INITSTAGE_LAST) {
+        getSimulation()->getSystemModule()->subscribe(POST_MODEL_CHANGE, this);
+//        if (fastLocalPropagation) {
+//            cModule *host = getContainingNode(this);
+//            host->subscribe(interfaceConfigChangedSignal, this);
+//        }
+    }
+}
+
+void Od3rGlobalRoutingPCE::initializePCE() {
+    numSuurballeComputations=0;
+    numDjikstraComputations=0;
+    numTopologyChangesPre=0;
+    numTopologyChangesPost=0;
+    numDefaultRouteMapsCreated=0;
+    if(!topologySet) setCurrentTopology();
+}
+void Od3rGlobalRoutingPCE::stop() {
+    topologySet = false;
+    shortestPathsCalculated = false;
+    lastChangeDetected = SIMTIME_ZERO;
+    lastestScheduledChange= SIMTIME_ZERO;
+    delete currentTopology;
+    for(auto topo: scheduledTopologies)
+        delete topo;
+    scheduledTopologies.clear();
+    for (auto message: scheduledUpdateMessages)
+        cancelAndDelete(message);
+    scheduledUpdateMessages.clear();
+}
+
+void Od3rGlobalRoutingPCE::receiveSignal(cComponent *source, simsignal_t signalID, cObject *obj, cObject *details)
+{
+    Enter_Method("%s", cComponent::getSignalName(signalID));
+    if(getSimulation()->getSimulationStage() == CTX_EVENT) { // unsure if helping?
+        //if(signalID == POST_MODEL_CHANGE) {
+            if (dynamic_cast<cPostParameterChangeNotification *>(obj)
+                    || dynamic_cast<cPostGateConnectNotification *>(obj)
+                    || dynamic_cast<cPostGateDisconnectNotification *>(obj)) {
+
+                printSignalBanner(signalID, obj, details);
+
+                if (topologySet && checkIfTopologyHasChangedAndAddToNextList()){
+                    noticeTopologyChangeDeteced();
+                    EV_INFO << "Topology changed changed\n";
+                }
+            }
+//        } else if (fastLocalPropagation && signalID == interfaceConfigChangedSignal) {
+//            printSignalBanner(signalID, obj, details);
+//            const auto *ieChangeDetails = check_and_cast<const NetworkInterfaceChangeDetails *>(obj);
+//            auto fieldId = ieChangeDetails->getFieldId();
+//            if (fieldId == NetworkInterface::F_NODE_OUT_GATEID || fieldId == NetworkInterface::F_NODE_IN_GATEID) {
+//                updateAllTopologies(ieChangeDetails->getNetworkInterface());
+//            }
+//        }
+    }
+}
+void Od3rGlobalRoutingPCE::handleMessageWhenUp(cMessage *msg)
+{
+    if (msg->isSelfMessage()) {
+        // scheduled next topology change
+        setTopologyToNext(msg);
+    }
+    else
+        throw cRuntimeError("Message not allowed");
+}
+void Od3rGlobalRoutingPCE::handleStartOperation(LifecycleOperation *operation)
+{
+    initializePCE();
+}
+void Od3rGlobalRoutingPCE::handleStopOperation(LifecycleOperation *operation)
+{
+    stop();
+}
+void Od3rGlobalRoutingPCE::handleCrashOperation(LifecycleOperation *operation)
+{
+    stop();
+}
+void Od3rGlobalRoutingPCE::finish() {
+    // Here could be your statistics
+    recordScalar("number suurballe computations", numSuurballeComputations);
+    recordScalar("number default routing table creations", numDefaultRouteMapsCreated);
+    recordScalar("number computation errors for non connected graph", numNoValidPath);
+    recordScalar("number suurballe errors for 1 connected graph", numSuurballeNot2Connected);
+    recordScalar("number suurballe routes too long", numSuurballePathTooLong);
+    recordScalar("number dijkstra computations", numDjikstraComputations);
+    recordScalar("number topology changes deteced", numTopologyChangesPre);
+    recordScalar("number topology changes set", numTopologyChangesPost);
+    recordScalar("number default routing table creations", numDefaultRouteMapsCreated);
+
+    RoutingProtocolBase::finish();
+}
+
+void Od3rGlobalRoutingPCE::noticeSuurballeComputation(double elapsedTimeDelta, double shortestPathCost,
+        double disjointPath1Cost, double disjointPath2Cost) {
+    ++numSuurballeComputations;
+    emit(suurballeComputationTimeSig, elapsedTimeDelta);
+    emit(suurballePathStrechPairs, (disjointPath1Cost + disjointPath2Cost) / (2*shortestPathCost));
+    emit(suurballePathStrechPath, disjointPath1Cost/shortestPathCost);
+    emit(suurballePathStrechPath, disjointPath2Cost/shortestPathCost);
+    emit(suurballePathStrechShortestPath, std::min(disjointPath1Cost, disjointPath2Cost) / shortestPathCost);
+}
+void Od3rGlobalRoutingPCE::noticeSuurballeComputationOn1ConnectedGraph(double elapsedTimeDelta) {
+    ++numSuurballeComputations;
+    ++numSuurballeNot2Connected;
+    emit(suurballeComputationTimeSig, elapsedTimeDelta);
+}
+void Od3rGlobalRoutingPCE::noticeSuurballeComputationPathTooLong(double elapsedTimeDelta, long path1Length, long path2Length) {
+    ++numSuurballeComputations;
+    ++numSuurballePathTooLong;
+    emit(suurballeComputationTimeSig, elapsedTimeDelta);
+    if (path1Length > 10) emit(suurballePathTooLong, path1Length);
+    if (path2Length > 10) emit(suurballePathTooLong, path2Length);
+}
+
+Od3rGlobalRoutingPCE::Ipv4DestCost Od3rGlobalRoutingPCE::getAddressForChildLinkInterface(Od3rGlobalTopology::Node* parent, Od3rGlobalTopology::Node* child) {
+    if(!child->isEnabled()) {
+        return std::make_pair(Ipv4Address::UNSPECIFIED_ADDRESS,DBL_MAX);
+    }
+    Od3rGlobalTopology::Link* candidate = nullptr;
+    for (size_t i = 0; i < parent->getNumOutLinks(); i++) {
+        Od3rGlobalTopology::Link* current_link = parent->getLinkOut(i);
+        if (!current_link->isEnabled())
+            continue;
+        if (current_link->getDestNode() == child) {
+            if ((!candidate) || candidate->getWeight() > current_link->getWeight()) {
+                candidate = current_link;
+            }
+        }
+    }
+    return candidate? std::make_pair(candidate->getDestAddr(),candidate->getWeight()) : std::make_pair(Ipv4Address::UNSPECIFIED_ADDRESS, DBL_MAX);
+}
+
+Od3rGlobalRoutingPCE::NodeMap Od3rGlobalRoutingPCE::createShortestPath(Od3rGlobalTopology::Node* source,
+        Od3rGlobalTopology::Node* dest) const {
+    NodeMap path;
+    auto node = dest;
+    while (node != source && node->getParentNode()) {
+        path[node] = node->getParentNode();
+        node = node->getParentNode();
+    }
+    return path;
+}
+
+Od3rGlobalRoutingPCE::NodeMap Od3rGlobalRoutingPCE::computeDijkstra(Od3rGlobalTopology::Node* source,
+        Od3rGlobalTopology::Node* dest, bool secondRound /* = false */, NodeMap path1 /* = {}*/) {
+    NodeDistMap distances;
+    NodeMap parents;
+
+    long startTime = clock();
+
+    // create priority queue
+    auto compare = [](std::pair<double, Od3rGlobalTopology::Node*> lhs, std::pair<double, Od3rGlobalTopology::Node*> rhs) {
+      // if (lhs.first == rhs.first) return lhs.second < rhs.second;
+      return lhs.first < rhs.first;
+    };
+    std::priority_queue<std::pair<double, Od3rGlobalTopology::Node*>, std::vector<std::pair<double, Od3rGlobalTopology::Node*>>, decltype(compare)> pq(compare);
+
+    for (int i = 0; i < currentTopology->getNumNodes(); i++) {
+        auto *node = (Od3rGlobalTopology::Node *) currentTopology->getNode(i); //?
+        distances.insert(std::make_pair(node, DBL_MAX)); // set distances to infinity
+        parents.insert(std::make_pair(node, nullptr)); // set parents to nullptr
+    }
+    distances[source] = 0; // set distance to root to zero
+    source->setDistanceToRoot(0);
+    pq.push(std::make_pair(0.0, source));// add root node to priority queue
+
+    while(!pq.empty()) {
+        double current_distance = pq.top().first;
+        Od3rGlobalTopology::Node* current_node = pq.top().second;
+        pq.pop();
+
+        if (current_distance > distances[current_node])
+            continue;  // only process node the first time it is in the queue
+
+        // Create residual path based on Suurballe Step 3.b: Reverse edges on path pointing towards the destination
+        if(secondRound && !(path1.find(current_node) == path1.end())) {
+            auto path_neighbor = path1[current_node];
+            if (current_distance < distances[path_neighbor]) {
+                distances[path_neighbor] = current_distance;
+                parents[path_neighbor] = current_node;
+                pq.push(std::make_pair(current_distance, path_neighbor));
+            }
+        }
+
+        for (size_t i = 0; i < current_node->getNumOutLinks(); i++) {
+            if (!current_node->getLinkOut(i)->isEnabled())
+                continue;
+
+            Od3rGlobalTopology::Node* neighbor = current_node->getLinkOut(i)->getDestNode();
+
+            if(!neighbor->isEnabled())
+                continue;
+
+            // creating residual path based on Suurballe step 3.a: Remove edges on path, directed to source
+            if (!((path1.find(neighbor) != path1.end()) && (current_node == path1[neighbor]))) {
+                // use weight function depending on Suurballe step 2
+                double distance = current_distance + current_node->getLinkOut(i)->getWeight();
+                if (secondRound)
+                    distance = distance - neighbor->getDistanceToRoot() + current_node->getDistanceToRoot();
+
+                if (distance < distances[neighbor]) {
+                    if(!secondRound) {
+                        neighbor->setDistanceToRoot(distance);
+                        neighbor->setParentNode(current_node);
+                    }
+                    distances[neighbor] = distance;
+                    parents[neighbor] = current_node;
+                    pq.push(std::make_pair(distance, neighbor));
+                }
+            }
+        }
+    }
+
+    NodeMap path;
+    auto node = dest;
+    while (node != source && parents[node]) {
+        path[node] = parents[node];
+        node = parents[node];
+    }
+    distances.clear();
+    parents.clear();
+    printElapsedTime("computeDijkstra", startTime);
+    noticeDijkstraCoputation();
+    return path;
+}
+
+std::pair<Od3rGlobalRoutingPCE::Ipv4PathStack,double> Od3rGlobalRoutingPCE::buildPath(NodeMap path1,
+        NodeMap path2, Od3rGlobalTopology::Node* source, Od3rGlobalTopology::Node* destination) {
+    Od3rGlobalTopology::Node* current_node = destination;
+    Ipv4PathStack addrPath;
+    double cost = 0.0;
+
+    while (current_node != source) {
+        if (path1.find(current_node) != path1.end()) {
+            Ipv4DestCost interfaceInfo = getAddressForChildLinkInterface(path1[current_node], current_node);
+            cost += interfaceInfo.second;
+            addrPath.push(interfaceInfo.first);
+            current_node = path1[current_node];
+        }
+        else if (path2.find(current_node) != path2.end()) {
+            Ipv4DestCost interfaceInfo = getAddressForChildLinkInterface(path2[current_node], current_node);
+            cost += interfaceInfo.second;
+            addrPath.push(interfaceInfo.first);
+            current_node = path2[current_node];
+        }
+        else throw cRuntimeError(this, "Paths are not compatible");
+    }
+    return std::make_pair(addrPath, cost);
+}
+
+IOd3rPathComputationElement::Ipv4PathPair Od3rGlobalRoutingPCE::computeSuurballe(const Ipv4Address &destAddr,
+        const Ipv4Address &routerId) {
+    Enter_Method("computeSuurballe(%u.%u.%u.%u)", destAddr.getDByte(0), destAddr.getDByte(1), destAddr.getDByte(2), destAddr.getDByte(3));
+    EV_INFO << "Computing disjoint routes for destination:" << destAddr << " using suurballe" << endl;
+    ASSERT(currentTopology);
+    ASSERT2(currentTopology->getNumNodes() > 0, "There are no routers in this topology"); // 1?
+
+    long startTime = clock();
+
+    Od3rGlobalTopology::Node* source = currentTopology->getNodeFromRouterId(routerId);
+    ASSERT2(source, "This module is not a router");
+    Od3rGlobalTopology::Node* dest = currentTopology->getNodeForDestByHighestPrefix(destAddr); // how to select correct
+    ASSERT2(dest, "No Router for the matching address found");
+
+    NodeMap path1;
+    if (shortestPathsCalculated)
+        path1 = createShortestPath(source, dest);
+    else {
+        path1 = computeDijkstra(source, dest);
+        shortestPathsCalculated = true;
+    }
+    if(path1.size() == 0) {
+        Ipv4PathPair noReturn;
+        noticeSuurballeComputationOnNoValidPath();
+        return noReturn;
+    }
+
+
+    NodeMap path2 = computeDijkstra(source, dest, true, path1);
+
+    NodeMap path2Copy(path2);
+
+    // Remove overlapping edges, i.e. edges, that are in different directions in both paths
+    for(NodeMap::iterator  iter = path2Copy.begin(); iter != path2Copy.end(); ++iter) {
+        Od3rGlobalTopology::Node* head = iter->first;
+        Od3rGlobalTopology::Node* tail = iter->second;
+        if ((path1.find(tail) != path1.end()) && path1[tail] == head) {
+            path1.erase(tail);
+            path2.erase(head);
+        }
+    }
+    Ipv4PathCost p1 = buildPath(path1, path2, source, dest);
+    Ipv4PathCost p2 = buildPath(path2, path1, source, dest);
+
+    long toc = clock();
+
+    // statistics stuff
+    // There could be something wrong, here only statistics, handling is done at a later point
+    if (path2Copy.size() == 0) { // graph is not 2 connected to this node
+        // use default route anyway -> only record
+        noticeSuurballeComputationOn1ConnectedGraph(static_cast<double>(toc - startTime) / CLOCKS_PER_SEC);
+    }
+    else if (p1.first.size() > 10 || p2.first.size() > 10) { // limitation due to maximum option length + 1 (since first element is not included)
+        // what to do....
+        // a) one could not insert the entry, but this would cause a recalculation each time a new request enters
+        // b) one could insert the shorter route twice, but what if both paths are longer than ten?
+        // c) one could insert a marker to use the default route instead
+
+        // handle statistics to not interfere with other correct calculations
+        noticeSuurballeComputationPathTooLong(static_cast<double>(toc - startTime) / CLOCKS_PER_SEC, p1.first.size(), p2.first.size());
+    }
+    else
+        noticeSuurballeComputation(static_cast<double>(toc - startTime) / CLOCKS_PER_SEC, dest->getDistanceToRoot() , p1.second, p2.second);
+
+    printElapsedTime("computeSurrballe", startTime);
+    return std::make_pair(p1.first, p2.first);
+}
+bool Od3rGlobalRoutingPCE::checkDisjointPathPairIfUseable(Ipv4PathPair pairToCheck) {
+    // if one list is longer than useable space or the two paths are the same we can't use the paths as disjoint paths
+    if (pairToCheck.first.size() > 10 || pairToCheck.second.size() > 10 || pairToCheck.first == pairToCheck.second
+            || pairToCheck.first.size() == 0 || pairToCheck.second.size() == 0)
+        return false;
+    return true;
+}
+
+void Od3rGlobalRoutingPCE::setCurrentTopology() {
+    Enter_Method("setCurrentTopology()");
+    if (topologySet)
+           delete currentTopology;
+    Topology* topo = new Topology();
+    topo->extractByProperty("networkRouter");
+    currentTopology = new Od3rGlobalTopology();
+    currentTopology->buildFromTopology(*topo);
+    topologySet = true;
+    shortestPathsCalculated = false;
+    delete topo;
+}
+void Od3rGlobalRoutingPCE::setTopology(Od3rGlobalTopology *topology) {
+    if (topologySet)
+       delete currentTopology;
+    currentTopology = topology;
+    topologySet = true;
+    shortestPathsCalculated = false;
+    long rest = scheduledTopologies.size();
+    emit(od3rTopologyChanged, rest);
+}
+void Od3rGlobalRoutingPCE::setTopologyToNext(cMessage *msg) {
+    setTopologyToNext();
+    scheduledUpdateMessages.pop_front();
+    delete msg;
+    noticeTopologyUpdated();
+}
+void Od3rGlobalRoutingPCE::setTopologyToNext() {
+    if (scheduledTopologies.size() == 0) throw cRuntimeError("No Topology to set");
+    setTopology(scheduledTopologies[0]);
+    scheduledTopologies.pop_front();
+}
+void Od3rGlobalRoutingPCE::addTopologyToNextList(Od3rGlobalTopology *topology) {
+    Enter_Method("addTopologyToNextList(...)");
+    if (scheduledTopologies.size() > 0 && scheduledUpdateMessages.size() > 0 // there is a next topology scheduled
+            && simTime() <= lastChangeDetected) { // this last message is in time window
+        EV_INFO << "Merge topology change events" << endl;
+        Od3rGlobalTopology *oldTopology = scheduledTopologies.back(); // remove last topology
+        scheduledTopologies.pop_back();
+        delete oldTopology;
+        //rescheduleAfter(*changePropagationDelayPar, scheduledUpdateMessages.back()); // reschedule last message
+    }
+    else { // no existing change in time window
+        EV_INFO << "Schedule new topology change event" << endl;
+        scheduledUpdateMessages.push_back(new cMessage("Od3rGlobalRoutingPCE::TopologyUpdate")); // add new message
+        simtime_t nextChangeTime = *changePropagationDelayPar + simTime();
+        // ensure that the change events do not leave the order due to random propagation time
+        nextChangeTime = nextChangeTime >= lastestScheduledChange ? nextChangeTime : lastestScheduledChange;
+        scheduleAt(nextChangeTime, scheduledUpdateMessages.back()); // schedule new message
+        lastChangeDetected = simTime(); // update change time
+        lastestScheduledChange = nextChangeTime; // since this change is the last change that occured
+    }
+    scheduledTopologies.push_back(topology); // add this topolgy
+}
+//void Od3rGlobalRoutingPCE::updateAllTopologies(NetworkInterface *ie) {
+//    if (ie->getNodeInputGateId() == -1 || ie->getNodeOutputGateId() == -1) { // link deleted
+//
+//    }
+//    else { //reconnected
+//        ie->get
+//    }
+//}
+
+bool Od3rGlobalRoutingPCE::checkIfTopologyHasChangedAndAddToNextList() {
+    Topology* topology = new Topology();
+    topology->extractByProperty("networkRouter");
+    Od3rGlobalTopology *cmpTopo = new Od3rGlobalTopology();
+    cmpTopo->buildFromTopology(*topology);
+    bool differs = scheduledTopologies.size() > 0 ? !scheduledTopologies.back()->equals(*cmpTopo) :
+                                                    !currentTopology->equals(*cmpTopo);
+    delete topology;
+    if (differs) {
+        addTopologyToNextList(cmpTopo);
+    }
+    else {
+        delete cmpTopo;
+    }
+    return differs;
+}
+bool Od3rGlobalRoutingPCE::checkIfTopologyHasChangedAndSetCurrentTopology() {
+    Topology* topology = new Topology();
+    topology->extractByProperty("networkRouter");
+    Od3rGlobalTopology *cmpTopo = new Od3rGlobalTopology();
+    cmpTopo->buildFromTopology(*topology);
+    bool differs = !currentTopology->equals(*cmpTopo);
+    delete topology;
+    if (differs) {
+        setTopology(currentTopology);
+    }
+    else {
+        delete cmpTopo;
+    }
+    return differs;
+}
+Ipv4Address Od3rGlobalRoutingPCE::getNetmaskForDestByHighestPrefix(const Ipv4Address &destAddr) const {
+    return currentTopology->getNetmaskForDestByHighestPrefix(destAddr);
+}
+
+bool Od3rGlobalRoutingPCE::isDirectlyConnectedInterfaceAddress(const Ipv4Address &ifAddress, Od3rGlobalTopology::Node* source,
+           Od3rGlobalTopology::Node* destination) const {
+    for (int k=0; k<destination->getNumInLinks();k++) {
+        if (destination->getLinkIn(k)->isEnabled() && ifAddress == destination->getLinkIn(k)->getDestAddr()) {
+            return destination->getLinkIn(k)->getSrcNode() == source;
+        }
+    }
+    return false;
+}
+
+bool Od3rGlobalRoutingPCE::isStubNetworkAddress(const Ipv4Address &address, Od3rGlobalTopology::Node* node) const {
+    for (int k=0; k<node->getNumOutLinks();k++) {
+        if (node->getLinkOut(k)->isEnabled() && address == node->getLinkOut(k)->getSrcAddr()) {
+            return false;
+        }
+    }
+    return true;
+}
+
+Od3rGlobalRoutingPCE::RouteMap Od3rGlobalRoutingPCE::createDefaultRoutingMap(const Ipv4Address &sourceRouterId) {
+    Enter_Method("createDefaultRoutingMap(%u.%u.%u.%u)", sourceRouterId.getDByte(0), sourceRouterId.getDByte(1), sourceRouterId.getDByte(2), sourceRouterId.getDByte(3));
+    std::map<Ipv4Address, std::set<std::pair<uint32_t, Ipv4Address>>> gateways;
+    Od3rGlobalTopology::Node* sourceNode = currentTopology->getNodeFromRouterId(sourceRouterId);
+    if (!shortestPathsCalculated) {
+        computeDijkstra(sourceNode, sourceNode);
+        shortestPathsCalculated = true;
+    }
+    ASSERT(sourceNode);
+    if (addDefaultRoutes && sourceNode->getNumOutLinks() == 1) { //since only connected to one interface not much to do
+       if (addDirectRoutes) {
+           // add a network route for the local network using ARP
+           for (int i = 0; i < sourceNode->getNumInterfaceAddr(); i++) {
+//               auto netmask = sourceNode->getInterfaceAddrNetmask(i);
+//               auto addr = sourceNode->getInterfaceAddr(i).doAnd(netmask);
+//               gateways[Ipv4Address::UNSPECIFIED_ADDRESS].insert(std::make_pair(32 - netmask.getNetmaskLength(), addr));
+               // FIX for unconnceted interfaces in RT
+               auto addr = sourceNode->getInterfaceAddr(i);
+               gateways[Ipv4Address::UNSPECIFIED_ADDRESS].insert(std::make_pair(0, addr));
+           }
+       }
+
+       // add a default route towards the only one gateway
+       gateways[sourceNode->getLinkOut(0)->getDestAddr()].insert(std::make_pair(32, Ipv4Address::UNSPECIFIED_ADDRESS));
+
+       // skip building and optimizing the whole routing table
+       EV_DEBUG << "Adding default routes to " << sourceNode->getRouterId() << ", node has only one (non-loopback) interface\n";
+       noticeDefaultRouteMapCreated();
+       return gateways;
+    }
+    for (int i=0; i < currentTopology->getNumNodes(); i++) {
+        Od3rGlobalTopology::Node* destinationNode = currentTopology->getNode(i);
+        if (destinationNode == sourceNode)
+            continue;
+        if (!destinationNode->getParentNode() || std::isinf(destinationNode->getDistanceToRoot()))
+            continue;
+        // bridgeNode is not possible in this topolgy
+
+        // find gateway/nexthop for this node
+        Od3rGlobalTopology::Node* neighborNode = destinationNode;
+        while (neighborNode->getParentNode() != sourceNode) {
+            neighborNode = neighborNode->getParentNode();
+        }
+        for(int l=0; l<destinationNode->getNumInterfaceAddr();l++) {
+            Ipv4Address address = destinationNode->getInterfaceAddr(l);
+
+            // TODO override to add ALL direct routes?
+            if (neighborNode == destinationNode && isDirectlyConnectedInterfaceAddress(address, sourceNode, destinationNode)) {
+                // handle directly connected neighbor -> add to unspecified gateway
+                gateways[Ipv4Address::UNSPECIFIED_ADDRESS].insert(std::make_pair(0, address));
+            }
+            else if (addSubnetRoutes && isStubNetworkAddress(address, destinationNode)) { // FIXME could yield double entries in case of broken links
+                // add Ipv4Address to list with interface netmask from link
+                auto netmask = destinationNode->getInterfaceAddrNetmask(l);
+                gateways[getAddressForChildLinkInterface(sourceNode,neighborNode).first].insert(std::make_pair(32 - netmask.getNetmaskLength(), address.doAnd(netmask)));
+            }
+            else {
+                // add Ipv4Address with ALLONES
+                gateways[getAddressForChildLinkInterface(sourceNode,neighborNode).first].insert(std::make_pair(0, address));
+            }
+        }
+    }
+    if (optimizeRoutes) {
+        for(auto& element: gateways) {
+            auto& addresses = element.second;
+            if (addresses.size() == 1)
+                continue;
+            if (element.first.isUnspecified())
+                continue;
+            for(std::set<std::pair<uint32_t, Ipv4Address>>::iterator itr = addresses.begin(); std::next(itr) != addresses.end(); ) {
+                auto lowerAddrPair = *itr;
+                auto higherAddrPair = *(std::next(itr));
+                if (lowerAddrPair.first == higherAddrPair.first) {
+                    // if old netmask is ALLONES and we want to combine two netmasks we need to consider network and broadcast addresses
+                    Ipv4Address newNetmask = lowerAddrPair.first == 0 ? Ipv4Address::makeNetmask(30) : Ipv4Address::makeNetmask(32 - lowerAddrPair.first-1);
+                    Ipv4Address newAddr = lowerAddrPair.second.doAnd(newNetmask);
+                    if(newAddr.equals(higherAddrPair.second.doAnd(newNetmask))) {
+                        addresses.erase(higherAddrPair);
+                        addresses.insert(std::make_pair(32 - newNetmask.getNetmaskLength(), newAddr));
+                        addresses.erase(itr++);
+                    }
+                    else
+                        ++itr;
+                }
+                else
+                    ++itr;
+            }
+            // if gateway has more addresses than currrent gateway with most adddresses
+            // compute biggest netmask and set this gateway as change candidate
+            //addresses.size();
+        }
+        // get gateway with highest number of addresses, check if netmask is bigger than /8
+        // if not remove all entries in addresses set for this gateway
+        // add single entry with address mask
+    }
+    noticeDefaultRouteMapCreated();
+    return gateways;
+}
+
+
+
+} /* namespace inet */
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.h inet_od3r/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.h
--- inet_orig/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.h	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,224 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#ifndef INET_NETWORKLAYER_OD3R_OD3RGLOBALROUTINGPCE_H_
+#define INET_NETWORKLAYER_OD3R_OD3RGLOBALROUTINGPCE_H_
+
+#include "IOd3rPathComputationElement.h"
+#include "inet/routing/base/RoutingProtocolBase.h"
+#include "inet/networklayer/od3r/Od3rGlobalTopology.h"
+#include  "inet/networklayer/od3r/Od3r.h"
+
+namespace inet {
+
+class IIpv4RoutingTable;
+class IInterfaceTable;
+class Od3r;
+
+class INET_API Od3rGlobalRoutingPCE: public IOd3rPathComputationElement, public RoutingProtocolBase, public cListener {
+protected:
+    typedef std::map<Od3rGlobalTopology::Node*, Od3rGlobalTopology::Node*> NodeMap;
+    typedef std::map<Od3rGlobalTopology::Node*, double> NodeDistMap;
+    typedef std::map<Ipv4Address, std::set<std::pair<uint32_t, Ipv4Address>>> RouteMap;
+public:
+    static simsignal_t od3rTopologyChanged;
+private:
+    ModuleRefByPar<IIpv4RoutingTable> rt;
+    ModuleRefByPar<IInterfaceTable> ift;
+    ModuleRefByPar<Od3r> od3r;
+
+    // State Stuff
+    Od3rGlobalTopology *currentTopology = nullptr;
+    std::deque<Od3rGlobalTopology *> scheduledTopologies;
+    std::deque<cMessage *> scheduledUpdateMessages;
+    simtime_t lastChangeDetected = SIMTIME_ZERO;
+    simtime_t lastestScheduledChange= SIMTIME_ZERO;
+    bool shortestPathsCalculated = false;
+    bool topologySet = false;
+
+    // Parameters
+    cPar *changePropagationDelayPar = nullptr;
+    simtime_t changeMergeJitter = SIMTIME_ZERO;
+    bool computeDefaultPaths = false;
+    bool addDefaultRoutes = true;
+    bool addDirectRoutes = true;
+    bool addSubnetRoutes = false;
+    bool optimizeRoutes = true;
+    bool fastLocalPropagation = true;
+
+    // stats
+    long numSuurballeComputations=0;
+    long numSuurballePathTooLong = 0;
+    long numSuurballeNot2Connected = 0;
+    long numDjikstraComputations=0;
+    long numTopologyChangesPre=0;
+    long numTopologyChangesPost=0;
+    long numDefaultRouteMapsCreated=0;
+    long numNoValidPath=0;
+
+    simsignal_t suurballeComputationTimeSig = registerSignal("od3rSuurballeComputationTime");
+    simsignal_t suurballePathStrechPairs = registerSignal("od3rPathPairStrech");
+    simsignal_t suurballePathStrechShortestPath = registerSignal("od3rShorterPathStrech");
+    simsignal_t suurballePathStrechPath = registerSignal("od3rPathStrech");
+    simsignal_t suurballePathTooLong = registerSignal("od3rPathTooLong");
+
+
+
+
+
+public:
+    virtual ~Od3rGlobalRoutingPCE();
+    Od3rGlobalRoutingPCE() { topologySet = false; shortestPathsCalculated = false;}
+    Ipv4PathPair computeSuurballe(const Ipv4Address &destAddr) {return {};}
+    Ipv4PathPair computeSuurballe(const Ipv4Address &destAddr, const Ipv4Address &routerId);
+    bool checkDisjointPathPairIfUseable(Ipv4PathPair pairToCheck);
+
+/**
+ * Block of module specific stuff
+ */
+protected:
+    virtual void initialize(int stage) override;
+    virtual int numInitStages() const override { return NUM_INIT_STAGES; }
+    virtual void handleMessageWhenUp(cMessage *msg) override;
+    virtual void finish() override;
+
+    virtual void initializePCE();
+    virtual void stop();
+
+    // cListener method
+    virtual void receiveSignal(cComponent *source, simsignal_t signalID, cObject *obj, cObject *details) override;
+
+public:
+    virtual void handleStartOperation(LifecycleOperation *operation) override;
+    virtual void handleStopOperation(LifecycleOperation *operation) override;
+    virtual void handleCrashOperation(LifecycleOperation *operation) override;
+
+private:
+    // stat methods
+    void noticeSuurballeComputation(double elapsedTimeDelta, double shortestPathCost, double disjointPath1Cost,
+            double disjointPath2Cost);
+    void noticeSuurballeComputationOn1ConnectedGraph(double elapsedTimeDelta);
+    void noticeSuurballeComputationPathTooLong(double elapsedTimeDelta, long path1Length, long path2Length);
+    inline void noticeDijkstraCoputation() { ++numDjikstraComputations;}
+    inline void noticeTopologyChangeDeteced() { ++numTopologyChangesPre;}
+    inline void noticeTopologyUpdated() { ++numTopologyChangesPost;}
+    inline void noticeDefaultRouteMapCreated() { ++numDefaultRouteMapsCreated;}
+    inline void noticeSuurballeComputationOnNoValidPath() { ++numNoValidPath; ++numSuurballeComputations; }
+
+
+private:
+    /**
+     * Returns the the destination Ipv4Address of the child node interface together with the link cost.
+     * If multiple links exists, the link with least cost is selected.
+     */
+    Ipv4DestCost getAddressForChildLinkInterface(Od3rGlobalTopology::Node* parent,
+            Od3rGlobalTopology::Node* child);
+    /**
+     * Returns true, if source and destination are directly connected through an enabled link and the destination
+     * address is the given interface address.
+     */
+    bool isDirectlyConnectedInterfaceAddress(const Ipv4Address &ifAddress, Od3rGlobalTopology::Node* source,
+            Od3rGlobalTopology::Node* destination) const;
+    /**
+     * Returns true, if the network could be a stub network, i.e., there is no enabled link with that interface address
+     * from the source node.
+     */
+    bool isStubNetworkAddress(const Ipv4Address &address, Od3rGlobalTopology::Node* node) const;
+    /**
+     * If the shorthest path is already calculated, this method builds the shorthest path between a source and destination
+     * node in the form of a node map.
+     */
+    NodeMap createShortestPath(Od3rGlobalTopology::Node* source, Od3rGlobalTopology::Node* dest) const;
+    /**
+     * Uses path node maps, which are used inside the suurbale computation to extract a single complete Ipv4 path
+     * between source and destination.
+     */
+    std::pair<Ipv4PathStack,double> buildPath(NodeMap path1, NodeMap path2,
+            Od3rGlobalTopology::Node* source, Od3rGlobalTopology::Node* destination);
+    /**
+     * Computes the shortest path. Second run together with the path allows to compute disjoint paths as speicified
+     * by Suurballe.
+     */
+    NodeMap computeDijkstra(Od3rGlobalTopology::Node* source, Od3rGlobalTopology::Node* dest,
+            bool secondRound = false, NodeMap path1 = {});
+
+    /**
+     * Sets the topology as current topology
+     */
+    void setTopology(Od3rGlobalTopology *topology);
+    /**
+     * Sets the current topology to the next scheduled topology
+     */
+    void setTopologyToNext();
+    /**
+     * Internal methods that calls setTopologyToNext() but also deletes the message triggering the change
+     */
+    void setTopologyToNext(cMessage *msg);
+    /**
+     * Adds and schedules a topology change
+     */
+    void addTopologyToNextList(Od3rGlobalTopology *topology);
+//    /**
+//     * Updates the topologies triggered by a local change
+//     */
+//    void updateAllTopologies(NetworkInterface *ie);
+    /**
+     * Checks if topology stored in currentTopolgy and a fresh extract of the topology differ.
+     * If there is a topology change detected, the change is scheduled using addTopologyToNextList(...) using the new
+     * topology.
+     */
+    bool checkIfTopologyHasChangedAndAddToNextList();
+    /**
+     * Checks if topology stored in currentTopolgy and a fresh extract of the topology differ.
+     * If there is a topology change detected, currentTopology is overwritten with the new topology.
+     */
+    bool checkIfTopologyHasChangedAndSetCurrentTopology();
+
+
+public:
+    /**
+     * Sets the topology to the globally extracted topology at the current simulation time.
+     */
+    void setCurrentTopology();
+
+    /**
+     * Returns true, if the shortest path is calculated for the currently set topology
+     */
+    bool isShortestPathCalculated() const { return shortestPathsCalculated; }
+    /**
+     * Returns true, if some topology is set.
+     */
+    bool isTopologySet() const { return topologySet; }
+
+
+    /**
+     * Returns a netmask to the longest prefix match of any node interface address with the corresonding
+     * destination address.
+     */
+    Ipv4Address getNetmaskForDestByHighestPrefix(const Ipv4Address &destAddr) const;
+    /**
+     * Creates a route map, which can be used to build shortest path routing table entries.
+     * The gateway node addresses are keys for the map. A unspecificed address indicates a direct connection.
+     */
+    RouteMap createDefaultRoutingMap(const Ipv4Address &sourceRouterId);
+
+
+};
+
+} /* namespace inet */
+
+#endif /* INET_NETWORKLAYER_OD3R_OD3RGLOBALROUTINGPCE_H_ */
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.ned inet_od3r/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.ned
--- inet_orig/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.ned	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3rGlobalRoutingPCE.ned	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,59 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+package inet.networklayer.od3r;
+
+//
+// Module used by the OD3R element of a router
+// The PCE enables computation of disjoint routes for a given, extracted topology
+// Further, the PCE can compute default shortest path routes
+// Upcomming changes in the topology are detected using POST_MODEL_CHANGE of OMNet++ and are scheduled to be used
+// after a given propagation delay. 
+//
+simple Od3rGlobalRoutingPCE
+{
+    parameters:
+        string interfaceTableModule;   // The path to the InterfaceTable module
+        string routingTableModule; // The path to the RoutingTable module
+        string od3rModule; // The path to the OD3R module
+        volatile double changePropagationTime @unit(s) = default(5s); // Time until the topology change is communicated and set
+        double changeMergeJitter @unit(ms) = default(10ms); // this is not supported atm
+        bool computeDefaultPaths = default(true); // allows computation of default shortest path routes
+        bool addDefaultRoutes = default(true); // adds default routes (ignored, if computeDefaultPaths=false)
+        bool addDirectRoutes = default(true); // adds routes for directly connected nodes (ignored, if computeDefaultPaths=false)
+        bool addSubnetRoutes = default(false); // this is broken (ignored, if computeDefaultPaths=false)
+        bool optimizeRoutes = default(true); // merges multiple routing table entries to a greater subnet mask one, if possible (ignored, if computeDefaultPaths=false)
+        bool fastLocalPropagation = default(true); // this is not supported atm
+        @display("i=block/routing");
+        @signal[od3rTopologyChanged](type=long);
+        
+        @signal[od3rSuurballeComputationTime](type=double);
+        @signal[od3rPathTooLong](type=long);
+        @signal[od3rPathPairStrech](type=double);
+        @signal[od3rShorterPathStrech](type=double);
+        @signal[od3rPathStrech](type=double);
+        @statistic[od3rSuurballeComputationTime](title="time spent in suurballe computation";
+        source=od3rSuurballeComputationTime;record=stats, timeavg; interpolationmode=none);
+        @statistic[od3rPathPairStrech](title="path strech of disjoint path pairs";
+        source=od3rPathPairStrech;record=histogram, timeavg; interpolationmode=none);
+        @statistic[od3rShorterPathStrech](title="path strech of shorther disjoint path";
+        source=od3rShorterPathStrech;record=histogram, timeavg; interpolationmode=none);
+        @statistic[od3rPathStrech](title="path strech per path";
+        source=od3rPathStrech;record=histogram, timeavg; interpolationmode=none);
+        @statistic[od3rPathTooLong](title="num hops of too long paths";
+        source=od3rPathTooLong;record=stats, timeavg; interpolationmode=none);
+}
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3rGlobalTopology.cc inet_od3r/src/inet/networklayer/od3r/Od3rGlobalTopology.cc
--- inet_orig/src/inet/networklayer/od3r/Od3rGlobalTopology.cc	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3rGlobalTopology.cc	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,297 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#include "Od3rGlobalTopology.h"
+
+#include "inet/networklayer/ipv4/IIpv4RoutingTable.h"
+#include "inet/common/stlutils.h"
+
+namespace inet {
+
+Register_Class(Od3rGlobalTopology);
+/**
+ * Topology Node
+ */
+Od3rGlobalTopology::Link *Od3rGlobalTopology::Node::getLinkIn(int i) const
+{
+    if (i < 0 || i >= (int)inLinks.size())
+        throw cRuntimeError("Od3rTopologyHelper::Node::getLinkIn: invalid link index %d", i);
+    return inLinks[i];
+}
+
+Od3rGlobalTopology::Link *Od3rGlobalTopology::Node::getLinkOut(int i) const
+{
+    if (i < 0 || i >= (int)outLinks.size())
+        throw cRuntimeError("Od3rTopologyHelper::Node::getLinkOut: invalid index %d", i);
+    return outLinks[i];
+}
+Ipv4Address Od3rGlobalTopology::Node::getInterfaceAddr(int i) const
+{
+    if (i < 0 || i >= (int)interfaceAddr.size())
+        throw cRuntimeError("Od3rTopologyHelper::Node::getInterfaceAddr: invalid index %d", i);
+    return interfaceAddr[i];
+}
+Ipv4Address Od3rGlobalTopology::Node::getInterfaceAddrNetmask(int i) const
+{
+    if (i < 0 || i >= (int)interfaceAddrNetmask.size())
+        throw cRuntimeError("Od3rTopologyHelper::Node::getInterfaceAddrNetmask: invalid index %d", i);
+    return interfaceAddrNetmask[i];
+}
+void Od3rGlobalTopology::Node::extractInterfaceIpv4Addresses(Topology::Node * topoNode) {
+    IInterfaceTable *interfaceTable = dynamic_cast<IInterfaceTable *>(topoNode->getModule()->getSubmodule("interfaceTable"));
+    if (interfaceTable) {
+        for(int j = 0; j < interfaceTable->getNumInterfaces(); j++) {
+            auto *interface = interfaceTable->getInterface(j);
+            if (interface && !interface->isLoopback()) { // ignore loopback interfaces and unspecified addresses
+                interfaceAddr.push_back(interface->getIpv4Address());
+                interfaceAddrNetmask.push_back(interface->getIpv4Netmask());
+            }
+        }
+    }
+}
+bool Od3rGlobalTopology::Node::equals(const Node& node) const {
+    if (this->isEnabled() != node.isEnabled())
+        return false;
+    if (this->getNumInLinks() != node.getNumInLinks()
+            || this->getNumOutLinks() != node.getNumOutLinks()
+            || this->getNumInterfaceAddr() != node.getNumInterfaceAddr())
+        return false;
+    for (int i = 0; i<getNumInLinks();i++) {
+        if (!getLinkIn(i)->equals(*node.getLinkIn(i)))
+            return false;
+    }
+    for (int i = 0; i<getNumOutLinks();i++) {
+        if (!getLinkOut(i)->equals(*node.getLinkOut(i)))
+            return false;
+    }
+    for (int i = 0; i<getNumInterfaceAddr();i++) {
+        if (!getInterfaceAddr(i).equals(node.getInterfaceAddr(i))
+                || !getInterfaceAddrNetmask(i).equals(node.getInterfaceAddrNetmask(i)))
+            return false;
+    }
+    return true;
+}
+
+/**
+ * Topology Link
+ */
+bool Od3rGlobalTopology::Link::equals(const Link& link) const {
+    return getDestAddr() == link.getDestAddr() && getSrcAddr() == link.getSrcAddr()
+            && getWeight() == link.getWeight() && isEnabled() == link.isEnabled();
+}
+
+
+/**
+ * Topology
+ */
+Od3rGlobalTopology::~Od3rGlobalTopology() {
+    clear();
+}
+
+Ipv4Address Od3rGlobalTopology::getRouterIdByTopologyNode(Topology::Node* node) const{
+    IIpv4RoutingTable * rt = dynamic_cast<IIpv4RoutingTable *>(node->getModule()->findModuleByPath(".ipv4.routingTable"));
+    return rt->getRouterId();
+}
+Ipv4Address Od3rGlobalTopology::getNodeInputIpv4Address(Topology::Link *linkOut) const {
+    IInterfaceTable *interfaceTable = dynamic_cast<IInterfaceTable *>(linkOut->getLinkInLocalNode()->getModule()->getSubmodule("interfaceTable"));
+    if(interfaceTable) {
+        NetworkInterface * networkInterface = interfaceTable->findInterfaceByNodeInputGateId(linkOut->getLinkOutRemoteGateId());
+        return networkInterface->getIpv4Address();
+    }
+    return Ipv4Address::UNSPECIFIED_ADDRESS;
+}
+Ipv4Address Od3rGlobalTopology::getNodeOutputIpv4Address(Topology::Link *linkOut) const {
+    IInterfaceTable *interfaceTable = dynamic_cast<IInterfaceTable *>(linkOut->getLinkOutLocalNode()->getModule()->getSubmodule("interfaceTable"));
+    if(interfaceTable) {
+        NetworkInterface * networkInterface = interfaceTable->findInterfaceByNodeOutputGateId(linkOut->getLinkOutLocalGateId());
+        return networkInterface->getIpv4Address();
+    }
+    return Ipv4Address::UNSPECIFIED_ADDRESS;
+}
+Od3rGlobalTopology::Node* Od3rGlobalTopology::getNodeFromRouterId(Ipv4Address routerId) {
+    for (auto node: nodes) {
+        if (node->getRouterId().equals(routerId))
+            return node;
+    }
+    ASSERT(false);
+    return nullptr;
+}
+
+void Od3rGlobalTopology::clear() {
+    for (auto& elem : nodes) {
+        for (auto& _j : elem->outLinks)
+            delete _j; // delete links from their source side
+        delete elem;
+    }
+    nodes.clear();
+}
+
+
+void Od3rGlobalTopology::buildFromTopology(Topology& topology) {
+    clear();
+    std::map<int, Node *> moduleIdToNode;
+    for (int i = 0; i < topology.getNumNodes(); i++) { //create all nodes and assign parameters
+        auto *topoNode = (Topology::Node *) topology.getNode(i);
+        auto *newNode = new Od3rGlobalTopology::Node();
+        newNode->routerId = getRouterIdByTopologyNode(topoNode); // use routerId as node identifier
+        moduleIdToNode[topoNode->getModuleId()] = newNode;
+        newNode->extractInterfaceIpv4Addresses(topoNode); // add all interface addresses, even for links not connecting routers
+        topoNode->isEnabled() ? newNode->enable() : newNode->disable();
+        addNode(newNode);
+    }
+    for (int i = 0; i < topology.getNumNodes(); i++) { // create the links and add them to the nodes
+        auto *topoNode = (Topology::Node *) topology.getNode(i);
+        auto *internalNode = moduleIdToNode[topoNode->getModuleId()];
+        for (int j = 0; j < topoNode->getNumOutLinks();j++){
+            auto *topoOutLink = (Topology::Link *) topoNode->getLinkOut(j);
+            auto *newLink = new Od3rGlobalTopology::Link(topoOutLink->getWeight());
+            topoOutLink->isEnabled() ? newLink->enable() : newLink->disable();
+            auto *remoteNode = moduleIdToNode[topoOutLink->getLinkOutRemoteNode()->getModuleId()];
+            addLink(newLink, internalNode, remoteNode);
+            newLink->setDest(remoteNode, getNodeInputIpv4Address(topoOutLink)); // required since routerId != link address
+            newLink->setSrc(internalNode, getNodeOutputIpv4Address(topoOutLink));
+        }
+    }
+    moduleIdToNode.clear(); // cleanup
+}
+
+bool Od3rGlobalTopology::equals(const Od3rGlobalTopology& cmp) {
+    if (!(this->nodes.size()==cmp.getNumNodes()))
+        return false;
+    for (int i=0;i<getNumNodes();i++) {
+        if (!getNode(i)->equals(*cmp.getNode(i)))
+            return false;
+    }
+    return true;
+}
+
+int Od3rGlobalTopology::addNode(Node *node) {
+    if (node->routerId == Ipv4Address::UNSPECIFIED_ADDRESS) {
+        nodes.push_back(node);
+        return nodes.size() - 1;
+    }
+    else {
+        auto it = std::lower_bound(nodes.begin(), nodes.end(), node, lessByRouterId);
+        it = nodes.insert(it, node);
+        return it - nodes.begin();
+    }
+}
+void Od3rGlobalTopology::deleteNode(Node *node) {
+    // remove outgoing links
+    for (auto& elem : node->outLinks) {
+        Link *link = elem;
+        unlinkFromDestNode(link);
+        delete link;
+    }
+    node->outLinks.clear();
+    // remove incoming links
+    for (auto& elem : node->inLinks) {
+        Link *link = elem;
+        unlinkFromSourceNode(link);
+        delete link;
+    }
+    node->inLinks.clear();
+    // remove from nodes[]
+    auto it = find(nodes, node);
+    ASSERT(it != nodes.end());
+    nodes.erase(it);
+
+    delete node;
+}
+
+void Od3rGlobalTopology::addLink(Link *link, Node *srcNode, Node *destNode){
+    // remove from graph if it's already in
+    if (link->srcNode)
+        unlinkFromSourceNode(link);
+    if (link->destNode)
+        unlinkFromDestNode(link);
+
+    // insert
+    if (link->srcNode != srcNode)
+        link->srcAddr = Ipv4Address::UNSPECIFIED_ADDRESS;
+    if (link->destNode != destNode)
+        link->destAddr = Ipv4Address::UNSPECIFIED_ADDRESS;
+    link->srcNode = srcNode;
+    link->destNode = destNode;
+    srcNode->outLinks.push_back(link);
+    destNode->inLinks.push_back(link);
+}
+
+void Od3rGlobalTopology::deleteLink(Link *link) {
+    unlinkFromSourceNode(link);
+    unlinkFromDestNode(link);
+    delete link;
+}
+
+void Od3rGlobalTopology::unlinkFromSourceNode(Link *link)
+{
+    std::vector<Link *>& srcOutLinks = link->srcNode->outLinks;
+    auto it = find(srcOutLinks, link);
+    ASSERT(it != srcOutLinks.end());
+    srcOutLinks.erase(it);
+}
+void Od3rGlobalTopology::unlinkFromDestNode(Link *link)
+{
+    std::vector<Link *>& destInLinks = link->destNode->inLinks;
+    auto it = find(destInLinks, link);
+    ASSERT(it != destInLinks.end());
+    destInLinks.erase(it);
+}
+
+Od3rGlobalTopology::Node *Od3rGlobalTopology::getNode(int i) const {
+    if (i < 0 || i >= (int)nodes.size())
+        throw cRuntimeError(this, "invalid node index %d", i);
+    return nodes[i];
+}
+
+
+Od3rGlobalTopology::Node* Od3rGlobalTopology::getNodeForDestByHighestPrefix(const Ipv4Address &destAddr) const {
+    Od3rGlobalTopology::Node* dest;
+    int bestPrefixMatch = 0;
+    for (int i = 0; i < getNumNodes(); i++) {
+        auto *node = (Od3rGlobalTopology::Node *) getNode(i);
+        // Has interface with correct networkmask for destination
+        for(int j = 0; j < node->getNumInterfaceAddr(); j++) {
+            auto addr = node->getInterfaceAddr(j);
+            int prefixMatch = addr.getNumMatchingPrefixBits(destAddr);
+            if (prefixMatch > bestPrefixMatch) {
+                bestPrefixMatch = prefixMatch;
+                dest = node;
+            }
+        }
+    }
+    return dest;
+}
+Ipv4Address Od3rGlobalTopology::getNetmaskForDestByHighestPrefix(const Ipv4Address &destAddr) const {
+    Ipv4Address destNetmask = Ipv4Address::UNSPECIFIED_ADDRESS;
+    int bestPrefixMatch = 0;
+    for (int i = 0; i < getNumNodes(); i++) {
+        auto *node = (Od3rGlobalTopology::Node *) getNode(i);
+        // Has interface with correct networkmask for destination
+        for(int j = 0; j < node->getNumInterfaceAddr(); j++) {
+            auto addr = node->getInterfaceAddr(j);
+            int prefixMatch = addr.getNumMatchingPrefixBits(destAddr);
+            if (prefixMatch > bestPrefixMatch) {
+                bestPrefixMatch = prefixMatch;
+                //destNetmask = node->getInterfaceAddrNetmask(j);
+            }
+        }
+    }
+    return Ipv4Address::makeNetmask(bestPrefixMatch);
+}
+
+} /* namespace inet */
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3rGlobalTopology.h inet_od3r/src/inet/networklayer/od3r/Od3rGlobalTopology.h
--- inet_orig/src/inet/networklayer/od3r/Od3rGlobalTopology.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3rGlobalTopology.h	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,159 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#ifndef INET_NETWORKLAYER_OD3R_OD3RGLOBALTOPOLOGY_H_
+#define INET_NETWORKLAYER_OD3R_OD3RGLOBALTOPOLOGY_H_
+
+#include "inet/networklayer/common/NetworkInterface.h"
+
+#include "inet/common/Topology.h"
+
+namespace inet {
+/**
+ * Helper Class to track of current topology per router
+ * Similar to the Topology class of INET API
+ */
+class INET_API Od3rGlobalTopology: public cOwnedObject {
+public:
+    class Link;
+
+    class INET_API Node {
+        friend class Od3rGlobalTopology;
+
+    protected:
+        Ipv4Address routerId;
+        std::vector<Link *> outLinks;
+        std::vector<Link *> inLinks;
+        std::vector<Ipv4Address> interfaceAddr;
+        std::vector<Ipv4Address> interfaceAddrNetmask;
+
+        double dist;
+        Node *parent;
+
+//        double weight;
+        bool enabled;
+//        int networkId;
+//        std::vector<Link *> outPaths;
+
+
+    public:
+        Node(Ipv4Address routerId = Ipv4Address::UNSPECIFIED_ADDRESS) {
+            this->routerId = routerId;
+            dist = DBL_MAX;
+            parent = nullptr;
+        }
+        virtual ~Node() {
+            interfaceAddrNetmask.clear();
+            interfaceAddr.clear();
+            outLinks.clear();
+            inLinks.clear();
+        }
+        Ipv4Address getRouterId() const { return routerId; }
+        int getNumOutLinks() const { return outLinks.size(); }
+        Link *getLinkOut(int i) const;
+        int getNumInLinks() const { return inLinks.size(); }
+        Link *getLinkIn(int i) const;
+        int getNumInterfaceAddr() const { return interfaceAddr.size(); }
+        Ipv4Address getInterfaceAddr(int i) const;
+        Ipv4Address getInterfaceAddrNetmask(int i) const;
+        double getDistanceToRoot() const {return dist;}
+        void setDistanceToRoot(double dist) {this->dist=dist;}
+        Node *getParentNode() const {return parent;}
+        void setParentNode(Node *parent) {this->parent=parent;}
+        bool isEnabled() const { return enabled; }
+        void enable() { enabled = true; }
+        void disable() { enabled = false; }
+        virtual bool equals(const Node& node) const;
+    protected:
+        void extractInterfaceIpv4Addresses(Topology::Node * topoNode);
+    };
+    class INET_API Link {
+        friend class Od3rGlobalTopology;
+
+    protected:
+        Node *srcNode;
+        Node *destNode;
+        Ipv4Address srcAddr;
+        Ipv4Address destAddr;
+        double weight;
+        bool enabled;
+
+    public:
+        Link(double metric = 1) {
+            this->weight = metric;
+            srcNode=destNode=nullptr;
+            srcAddr=destAddr=Ipv4Address::UNSPECIFIED_ADDRESS;
+            enabled=true;
+        }
+        virtual ~Link() {}
+        void setSrc(Node *srcNode, Ipv4Address srcAddr)  { this->srcAddr=srcAddr; this->srcNode=srcNode; }
+        void setDest(Node *destNode, Ipv4Address destAddr) { this->destAddr=destAddr; this->destNode=destNode; }
+        void setWeight(double weight) { this->weight = weight; }
+        Node* getSrcNode() const { return srcNode; }
+        Node* getDestNode() const { return destNode; }
+        Ipv4Address getSrcAddr() const { return srcAddr; }
+        Ipv4Address getDestAddr() const { return destAddr; }
+        double getWeight() const { return weight; }
+        bool isEnabled() const { return enabled; }
+        void enable() { enabled = true; }
+        void disable() { enabled = false; }
+        virtual bool equals(const Link& node) const;
+    };
+protected:
+    std::vector<Node *> nodes;
+
+
+    static bool lessByRouterId(Node *a, Node *b) { return a->routerId < b->routerId; } // TODO check unspecified at end?
+    static bool isRouterIdLess(Node *a, Ipv4Address routerId) { return a->routerId < routerId; }
+
+    /**
+     * Helper methods for topology extraction
+     */
+    Ipv4Address getRouterIdByTopologyNode(Topology::Node* node) const;
+    Ipv4Address getNodeInputIpv4Address(Topology::Link *linkOut) const;
+    Ipv4Address getNodeOutputIpv4Address(Topology::Link *linkOut) const;
+
+    void clear();
+
+    void unlinkFromSourceNode(Link *link);
+    void unlinkFromDestNode(Link *link);
+
+
+public:
+    Od3rGlobalTopology() {}
+    virtual ~Od3rGlobalTopology();
+
+    void buildFromTopology(Topology& topology);
+
+    bool equals(const Od3rGlobalTopology& cmp);
+
+    int addNode(Node *node);
+    void deleteNode(Node *node);
+
+    void addLink(Link *link, Node *srcNode, Node *destNode);
+    void deleteLink(Link *link);
+
+    int getNumNodes() const { return nodes.size(); }
+    Node *getNode(int i) const;
+    Node* getNodeFromRouterId(Ipv4Address routerId);
+    Node* getNodeForDestByHighestPrefix(const Ipv4Address &destAddr) const;
+    Ipv4Address getNetmaskForDestByHighestPrefix(const Ipv4Address &destAddr) const;
+};
+
+} /* namespace inet */
+
+#endif /* INET_NETWORKLAYER_OD3R_OD3RGLOBALTOPOLOGY_H_ */
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3r.h inet_od3r/src/inet/networklayer/od3r/Od3r.h
--- inet_orig/src/inet/networklayer/od3r/Od3r.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3r.h	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,215 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#ifndef INET_NETWORKLAYER_OD3R_OD3R_H_
+#define INET_NETWORKLAYER_OD3R_OD3R_H_
+
+#include <stack>
+
+#include "inet/common/ModuleRefByPar.h"
+
+
+#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs
+
+#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address
+#include "inet/networklayer/common/NetworkInterface.h"
+
+#include "inet/common/Topology.h"
+#include "inet/networklayer/ipv4/Ipv4Route.h"
+
+#include "inet/networklayer/ipv4/Ipv4OptionsTag_m.h"
+
+#include "inet/networklayer/od3r/Od3rTopologyPCE.h"
+#include "inet/networklayer/od3r/Od3rGlobalRoutingPCE.h"
+
+#include "inet/routing/base/RoutingProtocolBase.h"
+
+namespace inet {
+
+class IIpv4RoutingTable;
+class IInterfaceTable;
+class Od3rGlobalRoutingPCE;
+
+class INET_API Od3r: public RoutingProtocolBase, public cListener
+{
+protected:
+    typedef std::stack<Ipv4Address> Ipv4PathStack;
+    typedef std::pair<Ipv4PathStack, Ipv4PathStack> Ipv4PathPair;
+protected:
+    // Referenced Moduls
+    ModuleRefByPar<IIpv4RoutingTable> rt;
+    ModuleRefByPar<IInterfaceTable> ift;
+    ModuleRefByPar<Od3rGlobalRoutingPCE> pce;
+
+    // State
+    Ipv4Address routerId;
+
+    // Parameters
+    simtime_t computedRouteLifetime = SIMTIME_ZERO;
+    simtime_t exchangedRouteLifetime = SIMTIME_ZERO;
+    bool createDefaultRoutingTable = false;
+    bool dumpRoutingTableAfterChange = false;
+
+
+private:
+    // Control Stats
+    long numComputations=0;
+    long numStops=0;
+
+    // Packet Stats
+    long numSourceRouteExchangePackets=0, numResidualPathPackets=0, numResidualPathRequests=0;
+    simsignal_t exchangeIngressSRBytesSig = registerSignal("sourceRouteExchangeBytes");
+    simsignal_t exchangeIngressPIDBytesSig = registerSignal("ingressPIDExchangeBytes");
+
+    // Error States
+    long numMissingPIdRoutes=0, numMissingDefaultEntries=0, numDefaultPathDummyUse = 0;
+    long numPathInSoftDelete=0;
+    simsignal_t missingRTforPacketSig = registerSignal("missingPathIdRoute");
+    simsignal_t missingDefaultEntrySig = registerSignal("missingDefaultEntry");
+    simsignal_t defaultPathDummySig = registerSignal("usingDefaultPathDummy");
+    simsignal_t pathInSoftDeleteSig = registerSignal("pathInSoftDelete");
+
+    // RT Stats
+    long numAddedRoutes=0,numDecayedRoutes=0,numCurrRoutes=0;
+    simsignal_t currentRouteSig = registerSignal("currentOD3RRoutes");
+    long numRTRefreshments=0;
+
+
+
+private:
+    std::map<Ipv4Route*, cMessage*> scheduledRoutes;
+
+public:
+    Od3r();
+    virtual ~Od3r();
+
+/**
+ * Block of module specific stuff
+ */
+protected:
+    virtual void initialize(int stage) override;
+    virtual int numInitStages() const override { return NUM_INIT_STAGES; }
+    virtual void finish() override;
+
+    virtual void initializeOD3R();
+    virtual void stop();
+
+    void resetStatistics();
+    void setupStatistics();
+
+    void createDefaultRoutingTableEntries();
+
+    // cListener method
+    virtual void receiveSignal(cComponent *source, simsignal_t signalID, long l, cObject *details) override;
+
+    virtual void handleMessageWhenUp(cMessage *msg) override;
+
+public:
+    // lifecycle methods
+    virtual void handleStartOperation(LifecycleOperation *operation) override;
+    virtual void handleStopOperation(LifecycleOperation *operation) override;
+    virtual void handleCrashOperation(LifecycleOperation *operation) override;
+
+private:
+    // statistic methods
+    inline void noticeComputation() { numComputations++;}
+    inline void noticeRTRefreshment() { ++numRTRefreshments;}
+    inline void noticeNodeStop() { ++numStops; }
+    inline void noticeAddedRoute() {++numAddedRoutes; emit(currentRouteSig, ++numCurrRoutes);}
+    inline void noticeDecayRoute() { ++numDecayedRoutes; emit(currentRouteSig, --numCurrRoutes);}
+    inline void noticeNumCurrentRoutesChange(long _currRoutes) { emit(currentRouteSig, _currRoutes);}
+
+
+    /**
+     * Deletes a route entry from the routing table, which was scheduled to be deleted
+     */
+    void deleteExpiredRoutes(cMessage *msg);
+    /**
+     * Rebuilds the routing table by removing all input routes from it as well as invalid path id routes amd
+     * recalculates the input routes.
+     */
+    void rebuildInputRoutesInRT();
+    /**
+     * Adds a route entry and schedules its deletion after a certain threshold time
+     */
+    void addRouteEntry(Ipv4Route* re);
+    /**
+     * Add computed paths for the destination address as input routes to the RT.
+     * selected path indicates which path is used, i.e., the last refresh should be set.
+     */
+    virtual void addInputRouteEntrys(const Ipv4Address &destAddr, Ipv4PathPair paths, uint8_t selectedPath,
+            simtime_t routeExpiryTime);
+
+
+public:
+    /**
+     * Compute the disjoint paths via Surrballe for a given destination from the current node
+     */
+    virtual Ipv4PathPair computeDisjointPaths(const Ipv4Address &destAddr);
+    /**
+     * Checks wether a disjoint path pair is valid to be used, i.e. if each path is no longer than than 10
+     * and boths paths are not equal (this happens if the graph is not 2 connected)
+     */
+    virtual bool checkDisjointPathPairIfUseable(Ipv4PathPair pairToCheck);
+
+    /**
+     * Add computed paths for the destination address as input routes to the RT.
+     * selected path indicates which path is used, i.e., the last refresh should be set.
+     * Route lifetime is set to default.
+     */
+    virtual void addInputRouteEntrys(const Ipv4Address &destAddr, Ipv4PathPair paths, uint8_t selectedPath)
+    {addInputRouteEntrys(destAddr,paths,selectedPath,SIMTIME_ZERO);}
+    /**
+     * Add route with path id to RT, which was exchanged via source route option
+     */
+    virtual void addPathIdRouteEntry(const NetworkInterface& destIE, const Ipv4Address &destAddr,
+            const Ipv4OptionRecordRoute& sourceRouteTLV, const Ipv4Address& sourceNextHopAddr);
+    /**
+     * Returns the network interface connecting the source to the destination
+     */
+    NetworkInterface *getInterfaceForNeighborAddress(const Ipv4Address& neighborAddr);
+    /**
+     * Returns a netmask to the longest prefix match of any node interface address with the corresonding
+     * destination address.
+     */
+    Ipv4Address getNetmaskForDestByHighestPrefix(const Ipv4Address &destAddr) const;
+
+    /**
+     * Refresh route expiry and reschedule deletion
+     */
+    void refreshRouteEntry(Ipv4Route* re);
+
+    // Packet Statistics
+    void noticeSourceRouteExchange() { ++numSourceRouteExchangePackets;}
+    void noticeResidualPathPacket() { ++numResidualPathPackets;}
+    void noticeResidualPathRequest() { ++numResidualPathRequests;}
+
+    // Error States
+    void noticeMissingPidRoute() { emit(missingRTforPacketSig,++numMissingPIdRoutes);}
+    void noticeMissingDefaultRoute() {emit(missingDefaultEntrySig, ++numMissingDefaultEntries);}
+    void noticeDefaultPathDummyUse() {emit(defaultPathDummySig, ++numDefaultPathDummyUse);}
+    void noticePathInSoftDelete() {emit(pathInSoftDeleteSig, ++numPathInSoftDelete);}
+
+    // SR send
+    void noticeInitiateSRExchange(int length) { emit(exchangeIngressSRBytesSig, length+1); } // +1 due to 4 Byte alingment
+    void noticePathIdRequestReplace() { emit(exchangeIngressPIDBytesSig, 8); }
+
+};
+
+} /* namespace inet */
+
+#endif /* INET_NETWORKLAYER_OD3R_OD3R_H_ */
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3r.ned inet_od3r/src/inet/networklayer/od3r/Od3r.ned
--- inet_orig/src/inet/networklayer/od3r/Od3r.ned	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3r.ned	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,57 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+package inet.networklayer.od3r;
+
+//
+// General module for On-Demand Disjoint Dynamic Routing (OD3R)
+// Maintainence routes and acts as interface between the different elements, which are involved
+// This module is slightly oriented on the TED module from INET 
+//
+simple Od3r
+{
+    parameters:
+    	string interfaceTableModule;   // The path to the InterfaceTable module
+        string routingTableModule; // The path to the Routing Table module
+        string pceModule; // The path to the path computation element
+        double computedRouteLifetime @unit(s) = default(5s); // lifetime of computed routes
+        double exchangedRouteLifetime @unit(s) = default(5s); // lifetime of exchanged routes
+        bool createDefaultRoutingTable = default(true); // enables/disables creation of default shortest path routes
+        bool dumpRoutingTableAfterChange = default(false); // atm no function
+        @display("i=block/table");
+        @signal[sourceRouteExchangeBytes](type=long);
+        @signal[ingressPIDExchangeBytes](type=long);
+        @signal[missingPathIdRoute](type=long);
+        @signal[missingDefaultEntry](type=long);
+        @signal[usingDefaultPathDummy](type=long);
+        @signal[pathInSoftDelete](type=long);
+        @signal[currentOD3RRoutes](type=long);
+        @statistic[sourceRouteExchangeBytes](title="route exchange (bytes)"; source=sourceRouteExchangeBytes;
+        record=count,sum, histogram; interpolationmode=none);
+        @statistic[ingressPIDExchangeBytes](title="route pid overhead (bytes)"; source=ingressPIDExchangeBytes;
+        record=count,sum; interpolationmode=none);
+        @statistic[totalOverhead](title="route pid overhead (bytes)"; source=sum(ingressPIDExchangeBytes)+sum(sourceRouteExchangeBytes);
+        record=last; interpolationmode=none);
+//        @statistic[missingPathIdRoute](title="number packets with no matching pid entry"; source=missingPathIdRoute;
+//        record=last; interpolationmode=none);
+//        @statistic[missingDefaultEntry](title="number of missing default entries"; source=missingDefaultEntry;
+//        record=last; interpolationmode=none);;
+        @statistic[currentOD3RRoutes](title="number of routes currently in RT"; source=currentOD3RRoutes;
+        record=last, vector, histogram, timeavg; interpolationmode=none);
+
+        
+}
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3rTopologyPCE.cc inet_od3r/src/inet/networklayer/od3r/Od3rTopologyPCE.cc
--- inet_orig/src/inet/networklayer/od3r/Od3rTopologyPCE.cc	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3rTopologyPCE.cc	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,226 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#include "Od3rTopologyPCE.h"
+
+#include <queue>
+
+#include "inet/networklayer/contract/IInterfaceTable.h"
+#include "inet/networklayer/ipv4/IIpv4RoutingTable.h"
+
+namespace inet {
+
+Register_Class(Od3rTopologyPCE);
+
+NetworkInterface* Od3rTopologyPCE::getNodeInputInterface(Topology::Link *linkOut) const {
+    IInterfaceTable *interfaceTable = dynamic_cast<IInterfaceTable *>(linkOut->getLinkInLocalNode()->getModule()->getSubmodule("interfaceTable"));
+    if(interfaceTable) {
+        NetworkInterface * networkInterface = interfaceTable->findInterfaceByNodeInputGateId(linkOut->getLinkOutRemoteGateId());
+        return networkInterface;
+    }
+    return nullptr;
+}
+
+NetworkInterface* Od3rTopologyPCE::getNodeOutputInterface(Topology::Link *linkOut) const {
+    IInterfaceTable *interfaceTable = dynamic_cast<IInterfaceTable *>(linkOut->getLinkOutLocalNode()->getModule()->getSubmodule("interfaceTable"));
+    if(interfaceTable) {
+        NetworkInterface * networkInterface = interfaceTable->findInterfaceByNodeOutputGateId(linkOut->getLinkInLocalGateId());
+        return networkInterface;
+    }
+    return nullptr;
+}
+
+Topology::Node* Od3rTopologyPCE::getNodeForDestByHighestPrefix(Topology& topology, const Ipv4Address &destAddr) const {
+    Topology::Node* dest;
+    int bestPrefixMatch = 0;
+    for (int i = 0; i < topology.getNumNodes(); i++) {
+        auto *node = (Topology::Node *) topology.getNode(i);
+        // Has interface with correct networkmask for destination
+        IInterfaceTable *interfaceTable = dynamic_cast<IInterfaceTable *>(node->getModule()->getSubmodule("interfaceTable"));
+        if (interfaceTable) {
+            for(int j = 0; j < interfaceTable->getNumInterfaces(); j++) {
+                NetworkInterface * networkInterface = interfaceTable->getInterface(j);
+                int prefixMatch = networkInterface->getIpv4Address().getNumMatchingPrefixBits(destAddr);
+                if (prefixMatch > bestPrefixMatch) {
+                    bestPrefixMatch = prefixMatch;
+                    dest = node;
+                }
+            }
+        }
+    }
+    return dest;
+}
+
+Od3rTopologyPCE::Ipv4DestCost Od3rTopologyPCE::getAddressForChildLinkInterface(Topology::Node* parent, Topology::Node* child) const {
+    if(!child->isEnabled()) {
+        return std::make_pair(Ipv4Address::UNSPECIFIED_ADDRESS,DBL_MAX);
+    }
+    Topology::Link* candidate = nullptr;
+    for (size_t i = 0; i < parent->getNumOutLinks(); i++) {
+        Topology::Link* current_link = parent->getLinkOut(i);
+        if (!current_link->isEnabled())
+            continue;
+        if (current_link->getLinkInLocalNode() == child) {
+            if ((!candidate) || candidate->getWeight() > current_link->getWeight()) {
+                candidate = current_link;
+            }
+        }
+    }
+    if (!candidate)
+        return std::make_pair(Ipv4Address::UNSPECIFIED_ADDRESS,DBL_MAX);
+    NetworkInterface* networkInterface = getNodeInputInterface(candidate);
+    return networkInterface? std::make_pair(networkInterface->getIpv4Address(),candidate->getWeight()) : std::make_pair(Ipv4Address::UNSPECIFIED_ADDRESS, DBL_MAX);
+}
+
+Topology::Node* Od3rTopologyPCE::getNodeForThisModule(Topology& topology) const {
+    //return topology.getNodeFor(this->getParentModule());
+    return topology.getNode(0); // FIXME
+}
+
+std::pair<Od3rTopologyPCE::TopologyNodeMap, Od3rTopologyPCE::TopologyNodeDist>
+Od3rTopologyPCE::computeDijkstra(Topology& topology, Topology::Node* source, Topology::Node* dest,
+        bool secondRound /* = false */, TopologyNodeMap path1 /* = {}*/,
+        TopologyNodeDist old_distances /*= {}*/) const {
+    TopologyNodeDist distances;
+    TopologyNodeMap parents;
+
+    // create priority queue
+    auto compare = [](std::pair<double, Topology::Node*> lhs, std::pair<double, Topology::Node*> rhs) {
+      // if (lhs.first == rhs.first) return lhs.second < rhs.second;
+      return lhs.first < rhs.first;
+    };
+    std::priority_queue<std::pair<double, Topology::Node*>, std::vector<std::pair<double, Topology::Node*>>, decltype(compare)> pq(compare);
+
+    for (int i = 0; i < topology.getNumNodes(); i++) {
+        auto *node = (Topology::Node *) topology.getNode(i); //?
+        distances.insert(std::make_pair(node, DBL_MAX)); // set distances to infinity
+        parents.insert(std::make_pair(node, nullptr)); // set parents to nullptr
+    }
+    distances[source] = 0; // set distance to root to zero
+    pq.push(std::make_pair(0.0, source));// add root node to priority queue
+
+    while(!pq.empty()) {
+        double current_distance = pq.top().first;
+        Topology::Node* current_node = pq.top().second;
+        pq.pop();
+
+        if (current_distance > distances[current_node])
+            continue;  // only process node the first time it is in the queue
+
+        // Create residual path based on Suurballe Step 3.b: Reverse edges on path pointing towards the destination
+        if(!(path1.find(current_node) == path1.end())) {
+            auto path_neighbor = path1[current_node];
+            if (current_distance < distances[path_neighbor]) {
+                distances[path_neighbor] = current_distance;
+                parents[path_neighbor] = current_node;
+                pq.push(std::make_pair(current_distance, path_neighbor));
+            }
+        }
+
+        for (size_t i = 0; i < current_node->getNumOutLinks(); i++) {
+            if (!current_node->getLinkOut(i)->isEnabled())
+                continue;
+
+            Topology::Node* neighbor = current_node->getLinkOut(i)->getLinkOutRemoteNode();
+
+            if(!neighbor->isEnabled())
+                continue;
+
+            // creating residual path based on Suurballe step 3.a: Remove edges on path, directed to source
+            if (!((path1.find(neighbor) != path1.end()) && (current_node == path1[neighbor]))) {
+                // use weight function depending on Suurballe step 2 TODO
+                double distance = current_distance + current_node->getLinkOut(i)->getWeight();
+                if (secondRound)
+                    distance = distance - old_distances[neighbor] + old_distances[current_node];
+
+                if (distance < distances[neighbor]) {
+                    distances[neighbor] = distance;
+                    parents[neighbor] = current_node;
+                    pq.push(std::make_pair(distance, neighbor));
+                }
+            }
+        }
+    }
+    TopologyNodeMap path;
+    auto node = dest;
+    while (node != source) {
+        path[node] = parents[node];
+        node = parents[node];
+    }
+    return std::make_pair(path, distances);
+}
+
+std::pair<Od3rTopologyPCE::Ipv4PathStack,double> Od3rTopologyPCE::buildPath(TopologyNodeMap path1,
+        TopologyNodeMap path2, Topology::Node* source, Topology::Node* destination) {
+    Topology::Node* current_node = destination;
+    Ipv4PathStack addrPath;
+    double cost = 0.0;
+
+    while (current_node != source) {
+        if (path1.find(current_node) != path1.end()) {
+            Ipv4DestCost interfaceInfo = getAddressForChildLinkInterface(path1[current_node], current_node);
+            cost += interfaceInfo.second;
+            addrPath.push(interfaceInfo.first);
+            current_node = path1[current_node];
+        }
+        else if (path2.find(current_node) != path2.end()) {
+            Ipv4DestCost interfaceInfo = getAddressForChildLinkInterface(path2[current_node], current_node);
+            cost += interfaceInfo.second;
+            addrPath.push(interfaceInfo.first);
+            current_node = path2[current_node];
+        }
+        else throw cRuntimeError(this, "Paths are not compatible");
+    }
+    return std::make_pair(addrPath, cost);
+}
+
+IOd3rPathComputationElement::Ipv4PathPair Od3rTopologyPCE::computeSuurballe(const Ipv4Address &destAddr, cModule *sourceParent) {
+    EV_INFO << "Computing disjoint routes for destination:" << destAddr << " using suurballe" << endl;
+    Topology* topology = new Topology();
+    topology->extractByProperty("networkRouter"); // I only want Routers :(
+    ASSERT2(topology->getNumNodes() > 0, "There are no routers in this topology"); // 1?
+
+    //Topology::Node* source = getNodeForThisModule(*topology); // check if correct?
+    Topology::Node* source = topology->getNodeFor(sourceParent);
+    ASSERT2(source, "This module is not a router");
+    Topology::Node* dest = getNodeForDestByHighestPrefix(*topology, destAddr); // how to select correct
+    ASSERT2(dest, "No Router for the matching address found");
+
+    std::pair<TopologyNodeMap, TopologyNodeDist> dijkRun1 = computeDijkstra(*topology, source, dest);
+    TopologyNodeMap path1 = dijkRun1.first;
+    TopologyNodeMap path2 = computeDijkstra(*topology, source, dest, true, path1, dijkRun1.second).first;
+    TopologyNodeMap path2Copy(path2);
+
+    // Remove overlapping edges, i.e. edges, that are in different directions in both paths
+    for(TopologyNodeMap::iterator  iter = path2Copy.begin(); iter != path2Copy.end(); ++iter) {
+        Topology::Node* head = iter->first;
+        Topology::Node* tail = iter->second;
+        if ((path1.find(tail) != path1.end()) && path1[tail] == head) {
+            path1.erase(tail);
+            path2.erase(head);
+        }
+    }
+    Ipv4PathCost p1 = buildPath(path1, path2, source, dest);
+    Ipv4PathCost p2 = buildPath(path2, path1, source, dest);
+
+
+    //noticeComputation(p1.second + p2.second, dijkRun1.second[dest]);
+
+    return std::make_pair(p1.first, p2.first);
+}
+
+} /* namespace inet */
diff -Naur inet_orig/src/inet/networklayer/od3r/Od3rTopologyPCE.h inet_od3r/src/inet/networklayer/od3r/Od3rTopologyPCE.h
--- inet_orig/src/inet/networklayer/od3r/Od3rTopologyPCE.h	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/Od3rTopologyPCE.h	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,87 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+#ifndef INET_NETWORKLAYER_OD3R_OD3RTOPOLOGYPCE_H_
+#define INET_NETWORKLAYER_OD3R_OD3RTOPOLOGYPCE_H_
+
+#include "IOd3rPathComputationElement.h"
+
+#include "inet/networklayer/common/NetworkInterface.h"
+
+#include "inet/common/Topology.h"
+
+namespace inet {
+
+/**
+ * Module used by the OD3R element of a router.
+ * The PCE enables computation of disjoint routes for a given, extracted topology
+ * Further, the PCE can compute default shortest path routes
+ * Upcomming changes in the topology are detected using POST_MODEL_CHANGE of OMNet++ and are scheduled to be used
+ * after a given propagation delay.
+ */
+class INET_API Od3rTopologyPCE: public IOd3rPathComputationElement, public cObject {
+protected:
+    typedef std::map<Topology::Node*, Topology::Node*> TopologyNodeMap;
+    typedef std::map<Topology::Node*, double> TopologyNodeDist;
+public:
+    Od3rTopologyPCE() {}
+    virtual ~Od3rTopologyPCE() {}
+    virtual Ipv4PathPair computeSuurballe(const Ipv4Address &destAddr) {return {};}
+    virtual Ipv4PathPair computeSuurballe(const Ipv4Address &destAddr, cModule *sourceParent);
+
+protected:
+    /**
+     * Returns the interface of the INPUT node from the link (TO)
+     */
+    virtual NetworkInterface* getNodeInputInterface(Topology::Link *linkOut) const;
+    /**
+     * Returns the interface of the OUTPUT node from the link (FROM)
+     */
+    virtual NetworkInterface* getNodeOutputInterface(Topology::Link *linkOut) const;
+    /**
+     * Returns the node/router which has the interface with the highest prefix match for the given destination address
+     */
+    virtual Topology::Node* getNodeForDestByHighestPrefix(Topology & topology, const Ipv4Address &destAddr) const;
+    /**
+     * Returns the child interface (to) address between parent and child.
+     * If multiple interfaces between child and parent exist, the to interface on the link with the smallest weight is returned
+     */
+    virtual Ipv4DestCost getAddressForChildLinkInterface(Topology::Node* parent, Topology::Node* child) const;
+
+    /**
+     * Returns the topology node, which is the parent of this Ip Module
+     */
+    virtual Topology::Node* getNodeForThisModule(Topology& topology) const;
+
+    /**
+     * Computes the shortest path tree from the source. The parent node for each node in the topology is returned and their respective shortest distances
+     * Further allows for a second run to include the old distances for weight calculation according to Suurballe step 3
+     */
+    virtual std::pair<TopologyNodeMap, TopologyNodeDist>
+        computeDijkstra(Topology& topology, Topology::Node* source, Topology::Node* dest, bool secondRound = false, TopologyNodeMap path1 = {},
+                TopologyNodeDist old_distances = {}) const;
+    /**
+     * Builds the path from to maps, so that the path are continuous
+     * Returns a stack of addresses starting with the next address
+     */
+    virtual Ipv4PathCost buildPath(TopologyNodeMap path1,
+            TopologyNodeMap path2, Topology::Node* source, Topology::Node* destination);
+};
+
+} /* namespace inet */
+
+#endif /* INET_NETWORKLAYER_OD3R_OD3RTOPOLOGYPCE_H_ */
diff -Naur inet_orig/src/inet/networklayer/od3r/SimpleLinkStateRouting.ned inet_od3r/src/inet/networklayer/od3r/SimpleLinkStateRouting.ned
--- inet_orig/src/inet/networklayer/od3r/SimpleLinkStateRouting.ned	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/networklayer/od3r/SimpleLinkStateRouting.ned	2023-12-20 17:28:39.485268617 +0100
@@ -0,0 +1,25 @@
+//
+//  Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+package inet.networklayer.od3r;
+
+//
+// TODO auto-generated type
+//
+simple SimpleLinkStateRouting
+{
+}
diff -Naur inet_orig/src/inet/node/inet/Router.ned inet_od3r/src/inet/node/inet/Router.ned
--- inet_orig/src/inet/node/inet/Router.ned	2024-04-17 09:34:10.547007946 +0200
+++ inet_od3r/src/inet/node/inet/Router.ned	2023-12-20 17:28:39.488602005 +0100
@@ -13,6 +13,8 @@
 import inet.routing.contract.IOspf;
 import inet.routing.contract.IPim;
 import inet.routing.contract.IEigrp;
+import inet.networklayer.od3r.Od3r;
+import inet.networklayer.od3r.Od3rGlobalRoutingPCE;
 
 //
 // IPv4 router that supports wireless, Ethernet, PPP and external interfaces.
@@ -40,6 +42,7 @@
 module Router extends ApplicationLayerNodeBase
 {
     parameters:
+        @networkRouter;
         @display("i=abstract/router");
         @figure[submodules];
         forwarding = true;
@@ -49,9 +52,13 @@
         bool hasBgp = default(false);
         bool hasPim = default(false);
         bool hasDhcp = default(false);
+        bool hasOd3r = default(true); // atm all routeres default to have a OD3R Module \KAL
         hasUdp = default(hasRip || hasDhcp);
         hasTcp = default(hasBgp);
         *.routingTableModule = default("^.ipv4.routingTable");
+        **.hasOd3r = default(this.hasOd3r);
+        **.od3rModule = default(this.hasOd3r ? absPath(".od3r") : "");
+        **.pceModule = default(this.hasOd3r ? absPath(".od3rPCE") : "");
 
     submodules:
         ospf: <default("Ospfv2")> like IOspf if hasOspf {
@@ -81,6 +88,14 @@
                 enableIPv4 = parent.hasIpv4;
                 @display("p=1113,225");
         }
+        od3r: Od3r if hasOd3r {
+            parameters:
+                @display("p=72.256004,928.038;is=s");
+        }
+        od3rPCE: Od3rGlobalRoutingPCE if hasOd3r {
+            parameters:
+                @display("p=72.256004,1038.68;is=s");
+        }
 
     connections allowunconnected:
         ospf.ipOut --> tn.in++ if hasOspf;
diff -Naur inet_orig/src/inet/node/od3r/Od3rRouter.ned inet_od3r/src/inet/node/od3r/Od3rRouter.ned
--- inet_orig/src/inet/node/od3r/Od3rRouter.ned	1970-01-01 01:00:00.000000000 +0100
+++ inet_od3r/src/inet/node/od3r/Od3rRouter.ned	2023-12-20 17:28:39.488602005 +0100
@@ -0,0 +1,18 @@
+//
+// Author: Konrad Altenhofen 2023
+//
+// This program is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see http://www.gnu.org/licenses/.
+// 
+
+package inet.node.od3r;
diff -Naur inet_orig/src/inet/transportlayer/contract/udp/UdpControlInfo.msg inet_od3r/src/inet/transportlayer/contract/udp/UdpControlInfo.msg
--- inet_orig/src/inet/transportlayer/contract/udp/UdpControlInfo.msg	2024-04-17 09:34:10.603675369 +0200
+++ inet_od3r/src/inet/transportlayer/contract/udp/UdpControlInfo.msg	2023-12-20 17:28:39.545269581 +0100
@@ -42,6 +42,8 @@
     UDP_C_SETOPTION_UNBLOCK_MCAST_SRC = 12;
     UDP_C_SETOPTION_LEAVE_MCAST_SRC = 13;
     UDP_C_SETOPTION_SET_MCAST_SRC_FILTER = 14;
+    // \KAL
+    UDP_C_SETOPTION_SET_DISJOINT_PATH_REQ = 15;
 }
 
 //
@@ -182,6 +184,22 @@
 }
 
 //
+// \KAL
+// Control info for setting the disjoint path request on an UDP socket.
+// To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
+// and an and instance of this control info class attached.
+// -1 indicates to don't add a request, 0 and one 1 a request for the first path
+// or second path respecively. 256 indicates the request to duplicate the packet and send it on all paths (i.e. all two)
+//
+// @see ~UdpCommandCode
+//
+class UdpSetDisjointPathRequestCommand extends UdpSetOptionCommand
+{
+    optionCode = UDP_C_SETOPTION_SET_DISJOINT_PATH_REQ;
+    int pathSelector;
+}
+
+//
 // Control info for setting the DSCP (DiffServ Code Point)
 // header field on outgoing Ipv4/Ipv6 packets sent from an Udp socket.
 // This is a 6-bit field.
diff -Naur inet_orig/src/inet/transportlayer/contract/udp/UdpSocket.cc inet_od3r/src/inet/transportlayer/contract/udp/UdpSocket.cc
--- inet_orig/src/inet/transportlayer/contract/udp/UdpSocket.cc	2024-04-17 09:36:27.235393589 +0200
+++ inet_od3r/src/inet/transportlayer/contract/udp/UdpSocket.cc	2023-12-20 17:28:39.545269581 +0100
@@ -118,6 +118,16 @@
     sendToUDP(request);
 }
 
+// \KAL
+void UdpSocket::setDisjointPathRequest(int path_selector)
+{
+    auto request = new Request("setDisjointPathRequest", UDP_C_SETOPTION);
+    UdpSetDisjointPathRequestCommand *ctrl = new UdpSetDisjointPathRequestCommand();
+    ctrl->setPathSelector(path_selector);
+    request->setControlInfo(ctrl);
+    sendToUDP(request);
+}
+
 void UdpSocket::setDscp(short dscp)
 {
     auto request = new Request("setDscp", UDP_C_SETOPTION);
diff -Naur inet_orig/src/inet/transportlayer/contract/udp/UdpSocket.h inet_od3r/src/inet/transportlayer/contract/udp/UdpSocket.h
--- inet_orig/src/inet/transportlayer/contract/udp/UdpSocket.h	2024-04-17 09:34:10.603675369 +0200
+++ inet_od3r/src/inet/transportlayer/contract/udp/UdpSocket.h	2023-12-20 17:28:39.545269581 +0100
@@ -135,6 +135,12 @@
     void connect(L3Address remoteAddr, int remotePort);
 
     /**
+     * \KAL
+     * Add a disjoint path request option to sent packets.
+     */
+    void setDisjointPathRequest(int path_selector);
+
+    /**
      * Set the TTL (Ipv6: Hop Limit) field on sent packets.
      */
     void setTimeToLive(int ttl);
diff -Naur inet_orig/src/inet/transportlayer/udp/Udp.cc inet_od3r/src/inet/transportlayer/udp/Udp.cc
--- inet_orig/src/inet/transportlayer/udp/Udp.cc	2024-04-17 09:36:27.242060309 +0200
+++ inet_od3r/src/inet/transportlayer/udp/Udp.cc	2023-12-20 17:28:39.558603129 +0100
@@ -27,6 +27,7 @@
 #include "inet/networklayer/common/MulticastTag_m.h"
 #include "inet/networklayer/common/TosTag_m.h"
 #include "inet/networklayer/contract/IL3AddressType.h"
+#include "inet/networklayer/common/DisjointPathTag_m.h" // \KAL
 
 #ifdef INET_WITH_IPv4
 #include "inet/networklayer/ipv4/IcmpHeader.h"
@@ -260,6 +261,11 @@
                     setMulticastSourceFilter(sd, ie, cmd->getMulticastAddr(), cmd->getFilterMode(), sourceList);
                     break;
                 }
+                case UDP_C_SETOPTION_SET_DISJOINT_PATH_REQ: { // \KAL
+                    auto cmd = check_and_cast<UdpSetDisjointPathRequestCommand *>(ctrl);
+                    setDisjointPathReq(sd, cmd->getPathSelector());
+                    break;
+                }
                     throw cRuntimeError("Unknown subclass of UdpSetOptionCommand received from app: code=%d, name=%s", ctrl->getOptionCode(), ctrl->getClassName());
             }
             break;
@@ -447,6 +453,12 @@
     sd->reuseAddr = reuseAddr;
 }
 
+// \KAL
+void Udp::setDisjointPathReq(SockDesc *sd, int pathSelector)
+{
+    sd->disjointPathReq = pathSelector;
+}
+
 void Udp::joinMulticastGroups(SockDesc *sd, const std::vector<L3Address>& multicastAddresses, const std::vector<int> interfaceIds)
 {
     for (uint32_t k = 0; k < multicastAddresses.size(); k++) {
@@ -799,7 +811,23 @@
     packet->addTagIfAbsent<DispatchProtocolReq>()->setProtocol(l3Protocol);
     packet->setKind(0);
 
-    EV_INFO << "Sending app packet " << packet->getName() << " over " << l3Protocol->getName() << ".\n";
+    EV_INFO << "Sending app packet " << packet->getName() << " over " << l3Protocol->getName();
+    if (sd->disjointPathReq == 256 && true) { // \KAL
+        EV_INFO << " and duplicating packet with disjoint path requests";
+        auto* packetDup = packet->dup();
+        packet->addTagIfAbsent<DisjointPathReq>()->setPathSelector(0);
+        packetDup->addTagIfAbsent<DisjointPathReq>()->setPathSelector(1);
+
+        emit(packetSentSignal, packetDup);
+        emit(packetSentToLowerSignal, packetDup);
+        send(packetDup, "ipOut");
+        numSent++;
+    }
+    else if (sd->disjointPathReq >= 0 && sd->disjointPathReq <= 255 && true) { // \KAL
+        packet->addTagIfAbsent<DisjointPathReq>()->setPathSelector(sd->disjointPathReq);
+    }
+
+    EV_INFO << ".\n";
     emit(packetSentSignal, packet);
     emit(packetSentToLowerSignal, packet);
     send(packet, "ipOut");
diff -Naur inet_orig/src/inet/transportlayer/udp/Udp.h inet_od3r/src/inet/transportlayer/udp/Udp.h
--- inet_orig/src/inet/transportlayer/udp/Udp.h	2024-04-17 09:34:10.620342258 +0200
+++ inet_od3r/src/inet/transportlayer/udp/Udp.h	2023-12-20 17:28:39.558603129 +0100
@@ -91,6 +91,7 @@
         int ttl = -1;
         short dscp = -1;
         short tos = -1;
+        int disjointPathReq = -1; // \KAL
         MulticastMembershipTable multicastMembershipTable;
 
         MulticastMembershipTable::iterator findFirstMulticastMembership(const L3Address& multicastAddress);
@@ -159,6 +160,8 @@
 
     virtual void addMulticastAddressToInterface(NetworkInterface *ie, const L3Address& multicastAddr);
 
+    virtual void setDisjointPathReq(SockDesc *sd, int pathSelector); // \KAL
+
     // ephemeral port
     virtual ushort getEphemeralPort();
 
